<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java自学资源推荐</title>
    <url>/2020/04/26/Java%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>首推：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a> </p>
<p>一份java学习面试基础指南，涵盖Java程序员所需要掌握的核心知识。最重要的推荐里面的学习路线，对于准备开始学习者非常有益处。</p>
<p><a href="https://how2j.cn/" target="_blank" rel="noopener">how2j Java自学网站</a></p>
<p>这个网站里每个知识点都被拆成小块进行学习，重要的是每一部分都有对应的小练习。</p>
<p><a href="https://github.com/Snailclimb/awesome-java#%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">github开源项目推荐</a></p>
<p>包含了各种门类的开源项目，有基础性的有进阶，适合学习了一段时间后自己动手实践。</p>
<p>电子书籍：<a href="https://lingcoder.github.io/OnJava8/#/sidebar" target="_blank" rel="noopener">OnJava8中文版</a></p>
<p>持续更新中。。。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活】改善睡眠</title>
    <url>/2020/03/08/%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E7%9D%A1%E7%9C%A0/</url>
    <content><![CDATA[<blockquote>
<p><em>参考：斯坦福高效睡眠法</em> <br> <a href="https://www.bilibili.com/video/av47071593" target="_blank" rel="noopener"><em>斯坦福高效睡眠法，带你摆脱失眠之苦</em></a><br></p>
</blockquote>
<p><strong>黄金睡眠时间是入睡后的90分钟</strong><br>现代人常常因为生物钟紊乱而受到睡眠不良的困扰，睡眠不良又影响整体工作学习状态，我将我所了解到的睡眠建议记录如下。</p>
<h1 id="睡眠建议"><a href="#睡眠建议" class="headerlink" title="睡眠建议"></a>睡眠建议</h1><h2 id="1-睡前90分钟洗澡，前60分钟淋浴，睡前足浴"><a href="#1-睡前90分钟洗澡，前60分钟淋浴，睡前足浴" class="headerlink" title="1.睡前90分钟洗澡，前60分钟淋浴，睡前足浴"></a>1.睡前90分钟洗澡，前60分钟淋浴，睡前足浴</h2><h2 id="2-睡前保持单调无聊的状态"><a href="#2-睡前保持单调无聊的状态" class="headerlink" title="2.睡前保持单调无聊的状态"></a>2.睡前保持单调无聊的状态</h2><h2 id="3-在床上专注睡觉（不在床上玩手机，或者做其他事情）"><a href="#3-在床上专注睡觉（不在床上玩手机，或者做其他事情）" class="headerlink" title="3.在床上专注睡觉（不在床上玩手机，或者做其他事情）"></a>3.在床上专注睡觉（不在床上玩手机，或者做其他事情）</h2><h2 id="4-形成规律作息，从固定起床时间开始，再确定入睡时间"><a href="#4-形成规律作息，从固定起床时间开始，再确定入睡时间" class="headerlink" title="4.形成规律作息，从固定起床时间开始，再确定入睡时间"></a>4.形成规律作息，从固定起床时间开始，再确定入睡时间</h2><h2 id="5-睡前不看屏幕，避免看蓝光（可以开原彩显示True-tone以及夜览Night-Shift）"><a href="#5-睡前不看屏幕，避免看蓝光（可以开原彩显示True-tone以及夜览Night-Shift）" class="headerlink" title="5.睡前不看屏幕，避免看蓝光（可以开原彩显示True tone以及夜览Night Shift）"></a>5.睡前不看屏幕，避免看蓝光（可以开原彩显示True tone以及夜览Night Shift）</h2><h2 id="6-必须熬夜时先睡100分钟（黄金90分钟原理）"><a href="#6-必须熬夜时先睡100分钟（黄金90分钟原理）" class="headerlink" title="6.必须熬夜时先睡100分钟（黄金90分钟原理）"></a>6.必须熬夜时先睡100分钟（黄金90分钟原理）</h2><h2 id="7-两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）"><a href="#7-两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）" class="headerlink" title="7.两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）"></a>7.两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）</h2><h2 id="8-不要赖床，醒得早不想起床会是抑郁症的前兆"><a href="#8-不要赖床，醒得早不想起床会是抑郁症的前兆" class="headerlink" title="8.不要赖床，醒得早不想起床会是抑郁症的前兆"></a>8.不要赖床，醒得早不想起床会是抑郁症的前兆</h2><h2 id="9-起床后沐浴阳光一会有助于提升状态，时自身更加清醒。"><a href="#9-起床后沐浴阳光一会有助于提升状态，时自身更加清醒。" class="headerlink" title="9.起床后沐浴阳光一会有助于提升状态，时自身更加清醒。"></a>9.起床后沐浴阳光一会有助于提升状态，时自身更加清醒。</h2><h2 id="10-吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽"><a href="#10-吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽" class="headerlink" title="10.吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽"></a>10.吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽</h2><h2 id="11-下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）"><a href="#11-下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）" class="headerlink" title="11.下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）"></a>11.下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）</h2><h2 id="12-吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品"><a href="#12-吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品" class="headerlink" title="12.吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品"></a>12.吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品</h2><h2 id="13-白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）"><a href="#13-白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）" class="headerlink" title="13.白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）"></a>13.白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）</h2>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>python界面开发（GUI）实现</title>
    <url>/2020/03/08/python%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%88GUI%EF%BC%89%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="选择GUI库"><a href="#选择GUI库" class="headerlink" title="选择GUI库"></a>选择GUI库</h1><p>&#160; &#160; &#160;常见的支持python图形界面编程的模块包括：<strong>PyQt、PySide、PySide2、wxPython、Tkinter</strong>。<br><br>&#160; &#160; &#160;wxPython、Tkinter模块界面丑功能少不考虑使用。现今使用最为广泛的PyQt，其作为Python编程语言和Qt库的成功融合，功能强大界面美观，社区活跃，但是存在着版权问题（科研学术能够免费使用，商业开发则需要购买许可证），所以选用与PyQt类似的Pyside2进行开发。另外提一句，Pyside与Pyside2区别在于，Pyside支持python2，Pyside2支持python3。</p>
<h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>这是为了最后软件打包时的考虑，新的虚拟环境只安装必要的模块，这样最后打包时不会因为打包进额外的模块或库而变的过大。</p>
<h3 id="Anaconda下虚拟环境相关操作："><a href="#Anaconda下虚拟环境相关操作：" class="headerlink" title="Anaconda下虚拟环境相关操作："></a>Anaconda下虚拟环境相关操作：</h3><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><ul>
<li>查看当前存在哪些虚拟环境<br><code>conda env list</code> 或 <code>conda info -e</code> </li>
<li>查看安装了哪些包<br><code>conda list</code> </li>
<li>检查更新当前conda<br><code>conda update conda</code> <h4 id="虚拟环境操作"><a href="#虚拟环境操作" class="headerlink" title="虚拟环境操作"></a>虚拟环境操作</h4></li>
<li>创建新的虚拟环境<br><code>conda create -n your_env_name python=X.X（2.7、3.6等)</code>    </li>
<li>使用如下命令即可激活你的虚拟环境(即将python的版本改变)。<br><br>  linux:  <code>activate your_env_name(虚拟环境名称)</code><br><br>  Windows:  <code>activate your_env_name(虚拟环境名称)</code></li>
<li>安装package到your_env_name中<br><code>conda install -n your_env_name [package]</code></li>
<li>退出环境<br><code>source deactivate</code>    </li>
<li>即可删除虚拟环境<br><code>conda remove -n your_env_name(虚拟环境名称) --all</code> </li>
<li>删除环境中的某个包<br><br><code>conda remove --name your_env_name  package_name</code>  </li>
<li>检查当前python的版本<br><br><code>python --version</code></li>
</ul>
<h1 id="安装与使用PySide2"><a href="#安装与使用PySide2" class="headerlink" title="安装与使用PySide2"></a>安装与使用PySide2</h1><p>推荐教程 <br><br><a href="https://github.com/se7enXF/pyside2" target="_blank" rel="noopener">Python爱好者的Qt入门手册</a><br><br><a href="https://zhuanlan.zhihu.com/p/75637361" target="_blank" rel="noopener">使用PySide2开发GUI</a><br><br><a href="https://www.qt.io/cn/qt-for-python" target="_blank" rel="noopener">官方文档</a><br><br><a href="https://zmister.com/archives/category/guidevelop/" target="_blank" rel="noopener">州的先生博客</a></p>
<blockquote>
<p>补充：PySide包可以预先去<a href="http://download.qt.io/snapshots/ci/pyside/下载，再用pip安装。" target="_blank" rel="noopener">http://download.qt.io/snapshots/ci/pyside/下载，再用pip安装。</a><br><br>从.ui生成.py文件：<code>pyside2-uic [你保存的文件名].ui &gt; ui_mainwindow.py</code></p>
</blockquote>
<h1 id="使用过程中遇到的问题"><a href="#使用过程中遇到的问题" class="headerlink" title="使用过程中遇到的问题"></a>使用过程中遇到的问题</h1><h4 id="1-教程不详细，问题难解决"><a href="#1-教程不详细，问题难解决" class="headerlink" title="1.教程不详细，问题难解决"></a>1.教程不详细，问题难解决</h4><p>pyside2与PyQt极为相似，可以通过PyQt教程学习pyside的使用方法，搜索PyQt的类似问题来解决pyside使用过程中遇到的问题</p>
<h4 id="2-qt-designer中预览与实际程序运行不符"><a href="#2-qt-designer中预览与实际程序运行不符" class="headerlink" title="2.qt designer中预览与实际程序运行不符"></a>2.qt designer中预览与实际程序运行不符</h4><p>在<code>app = QtWidgets.QApplication(sys.argv)</code>之前，加上<code>QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)</code></p>
<h4 id="3-程序运行中界面无响应"><a href="#3-程序运行中界面无响应" class="headerlink" title="3.程序运行中界面无响应"></a>3.程序运行中界面无响应</h4><p>很可能是后台进行的函数阻塞了界面刷新，尝试多线程/多进程的方式分开界面与后台。</p>
<h2 id="图形界面中数据可视化（绘制折线图等）"><a href="#图形界面中数据可视化（绘制折线图等）" class="headerlink" title="图形界面中数据可视化（绘制折线图等）"></a>图形界面中数据可视化（绘制折线图等）</h2><p>参考：<a href="https://zmister.com/archives/187.html" target="_blank" rel="noopener">Python GUI教程（十三）：在GUI中使用pyqtgraph绘图库</a><br><a href="https://www.jb51.net/article/136397.htm" target="_blank" rel="noopener">Python使用matplotlib绘图无法显示中文问题的解决方法</a><br><a href="https://blog.csdn.net/panrenlong/article/details/80183519?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">在PyQt5设计的GUI界面中显示matplotlib绘制的图形</a><br><a href="https://wingsgo.github.io/2018/10/10/matplotlib-embedded.html" target="_blank" rel="noopener">在PySide2中嵌入matplotlib</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习记录</title>
    <url>/2020/03/02/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9C%89%E4%B8%80%E5%AE%9AC++%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p>作者有着C/C++的基础，在此记录学习Java过程中所了解的Java的一些特性。</p>
<blockquote>
<p>修订：强烈推荐GitHub上的<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/questions/java-learning-path-and-methods.md" target="_blank" rel="noopener">Java 学习路线和方法</a></p>
</blockquote>
<h1 id="数据类型方面"><a href="#数据类型方面" class="headerlink" title="数据类型方面"></a>数据类型方面</h1><ul>
<li>float与double类型在定义时需要在后面加上f/F与d/D</li>
<li>byte/short/char类型在进行运算时都会首先被提升为int型，而后计算。</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>数字字面量中允许包含下划线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Underscores &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d = 341_435_936.445_667;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111;</span><br><span class="line">        System.out.println(Integer.toBinaryString(bin));</span><br><span class="line">        System.out.printf(&quot;%x%n&quot;, bin); // [1]</span><br><span class="line">        long hex = 0x7f_e9_b7_aa;</span><br><span class="line">        System.out.printf(&quot;%x%n&quot;, hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.41435936445667E8</span><br><span class="line">101111101011111010111110101111</span><br><span class="line">2fafafaf</span><br><span class="line">7fe9b7aa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： Java 用 %n    实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 System.out.printf() 或 System.out.format() 时。对于 System.out.println()，我们仍然必须使用 \n；如果你使用 %n，println() 只会输出 %n 而不是换行符。</p>
<ul>
<li>移位运算符<br><br>移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。左移位运算符 <code>&lt;&lt;</code> 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。右移位运算符 <code>&gt;&gt;</code> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（<code>&gt;&gt;&gt;</code>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的。</li>
<li>Java没有sizeof<br><br>在 C/C++ 中，经常需要用到 sizeof() 方法来获取数据项被分配的字节大小。Java 不需要 sizeof() 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</li>
</ul>
</blockquote>
<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h2><ul>
<li>static的含义<br><br>static 方法中不会存在 this。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。</li>
<li>垃圾回收器<br><br>Java使用垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。并且由于垃圾回收的存在，使得 Java 没有析构函数。</li>
<li>初始化 <br><br>基本类型变量如果没有赋值会默认为0初始值。字符型为’/u0000’，布尔类型为False，引用为null。</li>
</ul>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>划分为5个部分</p>
<h4 id="1-栈（Stack）：存放方法中的局部变量，方法运行也在栈当中"><a href="#1-栈（Stack）：存放方法中的局部变量，方法运行也在栈当中" class="headerlink" title="1.栈（Stack）：存放方法中的局部变量，方法运行也在栈当中"></a>1.栈（Stack）：存放方法中的局部变量，方法运行也在栈当中</h4><p>局部变量：方法{}中的变量 与 方法的参数<br><br>作用域： 超出作用域，则从栈内存中消失。</p>
<h4 id="2-堆（Heap）：凡是new出来的东西都在其中"><a href="#2-堆（Heap）：凡是new出来的东西都在其中" class="headerlink" title="2.堆（Heap）：凡是new出来的东西都在其中"></a>2.堆（Heap）：凡是new出来的东西都在其中</h4><p>堆内存中的东西都有一个地址值（16进制）<br><br>堆内存中的东西都有默认值，规则如上</p>
<h4 id="3-方法区（Method-Area）：存储-class相关信息，包含方法的信息"><a href="#3-方法区（Method-Area）：存储-class相关信息，包含方法的信息" class="headerlink" title="3.方法区（Method Area）：存储.class相关信息，包含方法的信息"></a>3.方法区（Method Area）：存储.class相关信息，包含方法的信息</h4><h4 id="4-本地方法栈（Native-Method-Stack）：与操作系统相关"><a href="#4-本地方法栈（Native-Method-Stack）：与操作系统相关" class="headerlink" title="4.本地方法栈（Native Method Stack）：与操作系统相关"></a>4.本地方法栈（Native Method Stack）：与操作系统相关</h4><h4 id="5-寄存器（pc-Register）：与CPU相关"><a href="#5-寄存器（pc-Register）：与CPU相关" class="headerlink" title="5.寄存器（pc Register）：与CPU相关"></a>5.寄存器（pc Register）：与CPU相关</h4><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h4 id="1-关于私有类成员变量的设置或者获取的方法"><a href="#1-关于私有类成员变量的设置或者获取的方法" class="headerlink" title="1.关于私有类成员变量的设置或者获取的方法"></a>1.关于私有类成员变量的设置或者获取的方法</h4><p>命名规则为：SetXxx /  GetXxx ，并且Setter不能有返回值，Getter不能有参数。特别的，对于boolen数据类型方法Getter写为IsXxx。</p>
<h4 id="2-Java-标准类"><a href="#2-Java-标准类" class="headerlink" title="2.Java 标准类"></a>2.Java 标准类</h4><p>一个标准类至少有以下四个部分：<br><br>1.所有成员变量都由private修饰<br><br>2.每个成员变量都有对应的Getter/Setter<br><br>3.一个无参数的构造方法<br><br>4.一个全参数的构造方法<br></p>
<blockquote>
<p>这样的类也叫Java bean(Ideal中，在Code菜单栏下Generate可以自动生成对应代码)</p>
</blockquote>
<h4 id="3-静态修饰-static-相关"><a href="#3-静态修饰-static-相关" class="headerlink" title="3.静态修饰 static 相关"></a>3.静态修饰 static 相关</h4><p>1.静态成员变量类的所有对象共享<br><br>2.静态方法属于类，不属于对象，并且不可调用非静态内容。<br><br>3.静态代码块如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    内容</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>当第一次用到本类时，该部分执行唯一的一次，并且比构造方法先执行。一般用于一次性对静态成员变量赋值。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h4><ul>
<li><p>Java中继承使用 extends 关键字，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 子类 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类方法若是想访问重名的父类成员变量，可以使用 super 关键字，方法类似于 this。当子类方法名称与参数都和父类一致时，子类方法将覆盖父类方法，即重写（override）。</p>
<blockquote>
<p>注意： 重写必须满足 子类方法返回值小于等于父类范围 与 子类方法权限大于等于父类（public &gt; protect &gt; default &gt; private）</p>
</blockquote>
</li>
<li><p>子类对象构造时会先调用父类的构造方法(本质是在子类构造方法中编译器将默认插入<code>super()</code> ),可以通过super关键字在子类构造函数中调用父类的重载构造. 另外父类构造调用必须是子类构造方法的第一个语句,不能多次调用，并且不能与this构造方法同时出现.</p>
</li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4><ul>
<li>Java是单继承的，即只能有一个父类</li>
<li>Java可以多级继承，即父类还有父类</li>
<li>Java中父类可以有多个子类</li>
</ul>
<h4 id="3-抽象"><a href="#3-抽象" class="headerlink" title="3.抽象"></a>3.抽象</h4><ul>
<li>方法名前加上abstract并去掉大括号以分号结束，即构造了抽象方法</li>
<li>抽象方法所在类必须是抽象类，即在class之前加上abstract关键字。</li>
<li>抽象类不能直接使用，必须构造子类<strong>覆盖所有抽象方法</strong>，然后创建子类对象进行使用</li>
</ul>
<h3 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h3><p>接口是一种公共的规范标准。是Java语言比较独特的部分。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>关键字为interface。</p>
<ul>
<li>接口中能够包含的有：<br></li>
</ul>
<p>1.常量。以public static final 修饰，近似于【常量】，必须赋值。<em>（推荐命名规则：完全大写）</em><br><br>2.抽象方法。 抽象方法定义固定以public abstract 修饰（也可省略）。<br><br>3.默认方法（Java8以上）。为了解决接口升级问题，允许有方法体，由public default 修饰 <br><br>4.静态方法（Java8以上）。不能通过接口实现类的对象调用，通过接口名称直接调用。<br><br>5.私有方法（Java9以上）<br></p>
<ul>
<li>接口不能直接使用，需要实现类来“实现”。规则类似于继承，extends关键字改为implement。接口的实现类必须覆盖所有抽象方法。一个类可以实现多个接口，同时接口也可以多继承。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>代码中实现多态，即父类引用指向子类对象。又可以称为对象向上转型，即把子类对象当作父类来用。当需要调用子类所特有方法时，对象向下转型（还原），格式为 <code>子类名称 对象名 = （子类名称）父类对象</code>。</p>
<blockquote>
<p>可以使用 instanceof 来判断对象的类别，返回值为布尔型。 </p>
</blockquote>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><ul>
<li>文件类File ，基于File类可以完成查看文件是否存在，文件夹下有那些文件，查看文件大小等操作。</li>
<li>读取与写入文件则需要字节输入输出流 FileInputStream 与 FileOutputStream 。<br>读取文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span><br><span class="line">    File f =new File(&quot;d:/lol.txt&quot;);</span><br><span class="line">    //创建基于文件的输入流</span><br><span class="line">    FileInputStream fis =new FileInputStream(f);</span><br><span class="line">    //创建字节数组，其长度就是文件的长度</span><br><span class="line">    byte[] all =new byte[(int) f.length()];</span><br><span class="line">    //以字节流的形式读取文件所有内容</span><br><span class="line">    fis.read(all);</span><br><span class="line">    for (byte b : all) &#123;</span><br><span class="line">        //打印出来是65 66</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //每次使用完流，都应该进行关闭</span><br><span class="line">    fis.close();</span><br><span class="line">      </span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>写入文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 准备文件lol2.txt其中的内容是空的</span><br><span class="line">    File f = new File(&quot;d:/lol2.txt&quot;);</span><br><span class="line">    // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span><br><span class="line">    byte data[] = &#123; 88, 89 &#125;;</span><br><span class="line"> </span><br><span class="line">    // 创建基于文件的输出流</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(f);</span><br><span class="line">    // 把数据写入到输出流</span><br><span class="line">    fos.write(data);</span><br><span class="line">    // 关闭输出流</span><br><span class="line">    fos.close();</span><br><span class="line">     </span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意流使用完需要关闭，一般.close()即可。除了正常调用函数方式，把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</p>
</blockquote>
<ul>
<li>与之类似的是字符流：FileReader  FileWriter 。区别在于一个是byte 一个是char<br>。另外，<br>使用类似于<code>new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;));</code>可以转换编码</li>
<li>其他数据类型使用数据流DataInputStream与DataOutputStream 类操作。特别的，对象经过序列化后也可以通过ObjectInputStream/ObjectOutputStream来读写。<blockquote>
<p>注：把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口</p>
</blockquote>
</li>
<li>以上的使用都会频繁的读写硬盘，效率较低，为了改善这个问题，我们使用缓存流，读写在缓存区完成。对应的缓存流类是 BufferedReader。</li>
<li>从控制台读写数据通过system.in/system.out 示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        Scanner s = new Scanner(System.in);</span><br><span class="line">         </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String line = s.nextLine();</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="集合与框架"><a href="#集合与框架" class="headerlink" title="集合与框架"></a>集合与框架</h1><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><h4 id="1-ArrayList-集合类"><a href="#1-ArrayList-集合类" class="headerlink" title="1.ArrayList 集合类"></a>1.ArrayList 集合类</h4><p>不同于数组，长度可变。集合中数据类型固定，并且不能是基本数据类型。其实现List接口。<br><br>如果想存储基本数据类型，需要使用该基本数据类型对应的包装类。包装类：将基础数据类型首字母大写，特别的int 对应 Integer char对应 Character<br><br>集合创建格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>：<br>添加 add（） 获取 get（） 删除remove（）返回被删除值  查看大小 size（）<br><br><strong>遍历</strong>：一般有 for循环，iterator迭代器，增强型for循环三种方式。增强型for循环示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (Hero h : heros) &#123;</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-LinkedList-集合类"><a href="#2-LinkedList-集合类" class="headerlink" title="2.LinkedList 集合类"></a>2.LinkedList 集合类</h3><p>与ArrayList一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。LinkedList特别在于，除了实现了List接口外，LinkedList还实现了双向链表结构Deque（可以很方便的在头尾插入删除数据），以及Queue接口(队列)。<br></p>
<blockquote>
<p>Queue是先进先出队列 FIFO，常用方法：<br><br>&#160; &#160;offer 在最后添加元素<br><br>&#160; &#160;poll 取出第一个元素<br><br>&#160; &#160;peek 查看第一个元素<br></p>
</blockquote>
<p> ArrayList和LinkedList的区别:<br><br> ArrayList 插入，删除数据慢<br><br>LinkedList， 插入，删除数据快<br><br>ArrayList是<strong>顺序结构</strong>，所以定位很快，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。<br><br>LinkedList 是<strong>链表结构</strong>，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以定位慢</p>
<h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3.HashMap"></a>3.HashMap</h3><p>HashMap储存数据的方式是—— 键值对 <em>（类似python中的字典）</em> 对于HashMap而言，key是唯一的，不可以重复的。基本使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Hero&gt; heroMap = new HashMap&lt;String,Hero&gt;();</span><br><span class="line">heroMap.put(&quot;gareen&quot;, new Hero(&quot;gareen1&quot;));</span><br></pre></td></tr></table></figure>

<p>HashMap使用类似于字典的存储与查找方式，将键值转换为Hashcode保存，这样在查找数据时速度非常快。<br>与之类似的还有HashSet，Set中的元素，不能重复，并且没有顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">names.add(&quot;gareen&quot;);</span><br><span class="line"> </span><br><span class="line">//第二次插入同样的数据，是插不进去的，容器中只会保留一个</span><br><span class="line">names.add(&quot;gareen&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="4-Collection接口与Collections工具类"><a href="#4-Collection接口与Collections工具类" class="headerlink" title="4.Collection接口与Collections工具类"></a>4.Collection接口与Collections工具类</h3><p>Collection是 Set List Queue（先进先出队列）和 Deque（双向链表）的接口。List等都继承了Collection<br><br>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类。用来实现对集合数据的一些操作。常用方法如下：<br><br>reverse     反转<br><br>shuffle     混淆<br><br>sort    排序<br><br>swap    交换<br><br>rotate  滚动<br><br>synchronizedList    线程安全化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    numbers.add(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Collections.reverse(numbers);</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;翻转后集合中的数据:&quot;);</span><br><span class="line">System.out.println(numbers);</span><br></pre></td></tr></table></figure>

<p>特别的在对某类的对象进行排序时，需要通过Comparator重写排序的规则，或者在该类中实现Comparable接口。</p>
<h3 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h3><p>泛型是 JDK1.5 的一个新特性，其实就是一个『语法糖』，本质上就是编译器为了提供更好的可读性而提供的一种小「手段」，对于 JVM 运行时的性能是没有任何影响的。<br><br>泛型的用法是在容器后面添加<type>，Type可以是类，抽象类，接口。这样容器中就只能存放这种type（或者其子类）的内容。基本写法如下：<br><br><code>ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;()</code><br></type></p>
<ul>
<li><p>设计一个类的时候，在类的声明上，加上一个<t>，表示该类支持泛型。</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class MyStack&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;T&gt; values = new LinkedList&lt;T&gt;();</span><br><span class="line">       </span><br><span class="line">    public void push(T t) &#123;</span><br><span class="line">        values.addLast(t);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T pull() &#123;</span><br><span class="line">        return values.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T peek() &#123;</span><br><span class="line">        return values.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero</span><br><span class="line">        MyStack&lt;Hero&gt; heroStack = new MyStack&lt;&gt;();</span><br><span class="line">        heroStack.push(new Hero());</span><br><span class="line">        //不能放Item</span><br><span class="line">        heroStack.push(new Item());</span><br><span class="line">         </span><br><span class="line">        //在声明这个Stack的时候，使用泛型&lt;Item&gt;就表示该Stack只能放Item</span><br><span class="line">        MyStack&lt;Item&gt; itemStack = new MyStack&lt;&gt;();</span><br><span class="line">        itemStack.push(new Item());</span><br><span class="line">        //不能放Hero</span><br><span class="line">        itemStack.push(new Hero());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型通配符<br><br>分为三种：无界泛型通配符<code>?</code>,子类限定泛型通配符<code>? extends</code>,父类限定泛型通配符<code>? super</code>。<br>一般是为了解决复用性问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method(ArrayList&lt;?&gt; arr) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-Lambda表达式"><a href="#6-Lambda表达式" class="headerlink" title="6.Lambda表达式"></a>6.Lambda表达式</h3><p>一种简写语法，类似于简化的匿名类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">           </span><br><span class="line">        HeroChecker c = new HeroChecker() &#123;</span><br><span class="line">            public boolean test(Hero h) &#123;</span><br><span class="line">                return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;使用匿名类过滤&quot;);</span><br><span class="line">        filter(heros, c);</span><br><span class="line">        System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        filter(heros, h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</span><br><span class="line">        System.out.println(&quot;在Lambda表达式中使用静态方法&quot;);</span><br><span class="line">        filter(heros, h -&gt; TestLambda.testHero(h) );</span><br><span class="line">        System.out.println(&quot;直接引用静态方法&quot;);</span><br><span class="line">        filter(heros, TestLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static boolean testHero(Hero h) &#123;</span><br><span class="line">        return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的，还有lamda聚合操作，暂不细究。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><strong>创建多线程</strong>一般有三种方式：<br></li>
</ul>
<p>1.继承Thread类<br><br>2.实现Runnable接口<br><br>3.匿名类的方式<br><br>重写run方法后，调用start（）开始线程。<br></p>
<ul>
<li><p><strong>常见的线程方法</strong>：<br><br>sleep  当前线程暂停<br><br>join   加入到当前线程中    </p>
<br>
setPriority 线程优先级<br>
yield  临时暂停<br>
setDaemon 守护线程<br></li>
<li><p><strong>线程同步</strong><br>为了防止多个线程操作同一对象时造成混乱，提出同步。基本功能就是当某个线程操作某对象时，独占这个对象，其他线程不能更改。同步使用synchronized关键字或者lock对象。<br>1.synchronized 块，如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object someObject =new Object();</span><br><span class="line">synchronized (someObject)&#123;</span><br><span class="line">  //此处的代码只有占有了someObject后才可以执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  2 .在类的方法前，加上修饰符synchronized。这样外部线程访问该方法时即为独占状态。另外，如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类。一些HashSet,LinkedList,HashMap等等非线程安全的类可以转化为线程安全类。<br><br>  3 . 使用lock对象。与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。<br><br>  另外，lock中还有trylock方法，会指定时间内尝试对对象进行独占，使用这个方法可以比较有效的避免死锁的情况产生。</p>
</li>
<li><p><strong>线程交互</strong>  使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法<br></p>
<blockquote>
<p>wait()–<em>让占用了这个同步对象的线程，临时释放当前的占用，并且等待.</em> <br> notify()– <em>唤醒在此对象监视器上等待的单个线程</em><br><br>  notifyAll()–<em>唤醒在此对象监视器上等待的所有线程</em><br></p>
</blockquote>
<p>  Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：await, signal,signalAll 方法。</p>
</li>
<li><p><strong>线程池</strong><br>基本想法在于循环使用线程池中的线程。线程池类ThreadPoolExecutor。</p>
</li>
</ul>
<h1 id="JDBC–java与数据库的连接"><a href="#JDBC–java与数据库的连接" class="headerlink" title="JDBC–java与数据库的连接"></a>JDBC–java与数据库的连接</h1><p>这里以mysql为例</p>
<h3 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h3><ul>
<li><p>为项目导入mysql-jdbc的jar包，使用JDBC连接MySQL数据库的驱动为<a href="https://dev.mysql.com/downloads/windows/installer/8.0.html" target="_blank" rel="noopener">Connentor/J</a></p>
</li>
<li><p>解压并在ideal或者其他IDE中导入mysql-connector-java-8.0.13.jar包。</p>
</li>
<li><p>通过<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br>初始化驱动类com.mysql.jdbc.Driver</p>
</li>
<li><p>建立与数据库的连接。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">// 建立与数据库的Connection连接</span><br><span class="line">// 这里需要提供：</span><br><span class="line">// 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">// 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">// 数据库名称 how2java</span><br><span class="line">// 编码方式 UTF-8</span><br><span class="line">// 账号 root</span><br><span class="line">// 密码 admin</span><br><span class="line"></span><br><span class="line">Connection c = DriverManager</span><br><span class="line">    .getConnection(</span><br><span class="line">            &quot;jdbc:mysql://127.0.0.1:3306/how2java?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;,</span><br><span class="line">            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数据库进行操作<br>创建Statement是用于执行SQL语句</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Statement s = c.createStatement();</span><br><span class="line">// 准备sql语句</span><br><span class="line">String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</span><br><span class="line">s.execute(sql);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭连接<br><br>有两种方式，调用close方法（注意先关Statement，后关Connection） 或者使用try-with-resource的方式自动关闭连接</p>
<h3 id="特别的地方"><a href="#特别的地方" class="headerlink" title="特别的地方"></a>特别的地方</h3></li>
<li><p>JDBC中使用预编译STATEMENT—PreparedStatement<br><br>和 Statement一样，PreparedStatement也是用来执行sql语句的<br>与创建Statement不同的是，需要根据sql语句创建PreparedStatement<br>除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接。 这样做的好处在于可读性好，性能更好，预防sql注入式攻击。<br></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    String sql = &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">    try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">        // 根据sql语句创建PreparedStatement</span><br><span class="line">        PreparedStatement ps = c.prepareStatement(sql);</span><br><span class="line">    ) &#123;</span><br><span class="line">         </span><br><span class="line">        // 设置参数</span><br><span class="line">        ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">        ps.setFloat(2, 313.0f);</span><br><span class="line">        ps.setInt(3, 50);</span><br><span class="line">        // 执行</span><br><span class="line">        ps.execute();</span><br><span class="line">  </span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正常操作会将数据库相关的操作都封装在一个类/接口里面，叫做数据访问对象。</p>
</li>
<li><p>与线程池类似的，数据库也有一个数据库连接池。<br><br>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面借用，而不是自己重新创建.<br>使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。<br>整个过程，这些连接都不会被关闭，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
<h1 id="常用类与函数"><a href="#常用类与函数" class="headerlink" title="常用类与函数"></a>常用类与函数</h1><h4 id="2-字符串类"><a href="#2-字符串类" class="headerlink" title="2.字符串类"></a>2.字符串类</h4><p>java程序中所有出现的双引号字符串都是String类的对象<br><br>字符串创建后不可更改。<br><br>字符串除了可以直接创建外，还可以通过字符数组或者字节数组创建。注意，直接创建的字符串放在字符串常量池中，相同字符串在池中只创建一次。<br><br>与之类似的StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br></p>
</li>
</ul>
<p><strong>常用方法</strong>：<br></p>
<ul>
<li><p>比较/忽略大小写比较： equals（） / equalsIgnoreCase()</p>
<blockquote>
<p>一般将常量字符串写在前面，例如：”abc”.equals(str)</p>
</blockquote>
</li>
<li><p>获取字符串长度： int length（）<br></p>
</li>
<li><p>拼接并返回新字符串： String concat（String str）<br></p>
</li>
<li><p>获取索引位置字符： char charAt（int index）<br></p>
</li>
<li><p>查找参数字符串在本字符串中首次出现的位置： int indexOf（String str）<br></p>
</li>
<li><p>字符串截取 参数位置到结尾/【begin，end）： String substring（int index/int begin，int end）<br></p>
</li>
<li><p>拆分成字符数组： char[] toCharArray()<br></p>
</li>
<li><p>拆分成字节数组： byte[] getBytes()<br></p>
</li>
<li><p>替换 ： String replace（CharSequence oldString， CharSequence newstring）<br></p>
</li>
<li><p>分割字符串： String[] split(String regex)<br></p>
</li>
</ul>
<h4 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h4><p>这是个与数组相关的工具类，里面包含许多有用的静态方法，例如：</p>
<ul>
<li>Stirng toString（数组）：数组转字符串（默认格式，即类似于[元素1，元素2，元素3，…]）</li>
<li>void sort（数组）：数组排序，默认升序<h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类<br></h4>数学相关的工具类</li>
</ul>
<p><strong>常用方法</strong>有：<br></p>
<ol>
<li>double abs(double num)  获取绝对值</li>
<li>double ceil(double num) 向上取整</li>
<li>double floor(double num) 向下取整</li>
<li>long round(double num)  四舍五入</li>
<li>Math.PI 近似圆周率<h4 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h4>util.Date类：时间原点，其对应的日期是1970年1月1日 8点0分0秒，以此为基准，每过一毫秒，就+1。getTime() 得到一个long型的整数。直接打印对象，会看到 “Tue Jan 05 09:51:48 CST 2016” 这样的格式。想要转化为好看的格式就需要下面的类。</li>
</ol>
<p>SimpleDateFormat 日期格式化类：构造方法类似<code>SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; )</code>。之后使用.format(Data)方法返回对应格式的字符串。也可以通过.parse(str)将字符串转为日期类。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常分类： 可查异常，运行时异常和错误3种。异常分Error和Exception<br>Exception里又分运行时异常和可查异常。Exception和Error的父类是Throwable，<br>所以在捕捉的时候，也可以使用Throwable进行捕捉。java也允许自定义异常。<br><br>java通过try catch 处理异常，也可以加入finally代码段（无论是否异常，都将执行）或者通过throw/throws关键字抛出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void method1() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void method2() throws FileNotFoundException &#123;</span><br><span class="line"> </span><br><span class="line">    File f = new File(&quot;d:/LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;试图打开 d:/LOL.exe&quot;);</span><br><span class="line">    new FileInputStream(f);</span><br><span class="line">    System.out.println(&quot;成功打开&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ideal相关"><a href="#Ideal相关" class="headerlink" title="Ideal相关"></a>Ideal相关</h1><h4 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h4><p>Alt+Enter  修正代码<br><br>ctrl+Y    删除光标所在行<br><br>ctrl+D    复制所在行并插入光标位置下面<br><br>ctrl+Alt+L  格式化代码<br><br>ctrl+/     注释当前行<br><br>ctrl+shift+/  注释多行<br><br>Alt+insert    自动生成代码<br><br>Alt+Shift+上下箭头 移动当前行<br></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网站资源整理</title>
    <url>/2020/02/25/%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>记录下所搜集的有价值的网站</p>
<h1 id="1-信息获取"><a href="#1-信息获取" class="headerlink" title="1.信息获取"></a>1.信息获取</h1><ul>
<li><a href="https://www.kaolamedia.com/" target="_blank" rel="noopener">新媒体导航</a><br>门户式网站，主要面向新媒体从业者。内容很多，非从业者也值得一看，集合了许多工具网站，数据网站，流量报价网站的入口。</li>
<li><a href="https://tophub.today/" target="_blank" rel="noopener">全网热点</a><br>将大部分知名的平台的热点榜单集合到一个网站上，总览全网热点。</li>
</ul>
<h1 id="2-日常工具"><a href="#2-日常工具" class="headerlink" title="2.日常工具"></a>2.日常工具</h1><ul>
<li><a href="https://slidesgo.com/" target="_blank" rel="noopener">slidesgo</a><br>一个PPT模板网站，风格简洁且不失时尚感，当然重点在于免费，免费，免费！</li>
<li><a href="http://www.eshow365.com/" target="_blank" rel="noopener">展会</a><br>提供全国的展会信息，了解到感兴趣的展会后可去其官网领门票，一般都是免费发放。</li>
<li><a href="http://bg-patterns.com/" target="_blank" rel="noopener">背景素材</a><br>免费的背景素材库，多种格式可选。</li>
<li><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨</a><br>能将背景声与人声分离，效果不错，每日有限定的免费次数。</li>
<li><a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">数据可视化</a><br>非常专业且实用的数据可视化制作网站，功能强大。</li>
<li><a href="https://www.msdmanuals.com/zh#%20mission" target="_blank" rel="noopener">默沙东诊疗手册</a><br>全面且专业的医疗手册，既有专业人士版本也有通俗的大众版，能比较有效的分析可能病症，比百度靠谱多个梯度，值得每个人收藏。</li>
<li><a href="https://www.materialtools.com/" target="_blank" rel="noopener">临时验证码</a><br>对于一些只想临时使用，但是需要注册验证的网站，填写这个网站里的电话号码，用它帮你完成验证，避免被电话骚扰。</li>
<li><a href="https://temp-mail.org/zh/" target="_blank" rel="noopener">临时邮箱</a><br>与临时验证码类似，可以用该网站上的邮箱完成注册验证。</li>
<li><a href="https://www.weiciyun.com/" target="_blank" rel="noopener">词云生成</a><br>较为简单实用的词云在线生成网站。</li>
</ul>
<h1 id="3-趣味类"><a href="#3-趣味类" class="headerlink" title="3.趣味类"></a>3.趣味类</h1><ul>
<li><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">大像素</a><br>一个神奇的网站，所拍摄的照片像素量极大，这意味每一张都存有大量的信息，你可以放大放大再放大体会这种神奇的感觉。</li>
<li><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史</a><br>再这个网站可以了解全球的历史大事脉络，还有许多神奇的功能。</li>
<li><a href="https://learningmusic.ableton.com" target="_blank" rel="noopener">音乐入门</a><br>可视化的教授做音乐的一些基础知识理论的网站。</li>
<li><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI捏人</a><br>非常有趣的网站，可以将不同风格的人物混合得到新的人物概念。通过尝试与调整可以获得独一无二的人物图片。</li>
<li><a href="https://neave.com/" target="_blank" rel="noopener">小集合</a><br>一个外网大佬的网站集合，包括实时地球卫星图，星象图等，既有趣味又有价值。</li>
<li><a href="http://www.shushubuyue.net/#" target="_blank" rel="noopener">匿名聊天网</a><br>网页版匿名的聊天室，挺有意思，还带一点温馨。</li>
</ul>
<h1 id="4-艺术"><a href="#4-艺术" class="headerlink" title="4.艺术"></a>4.艺术</h1><ul>
<li><a href="https://www.ianfisherart.com/" target="_blank" rel="noopener">云</a><br>一个专注于画云的艺术家的作品站，风格独著。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>网站资源</tag>
      </tags>
  </entry>
  <entry>
    <title>window下提升流畅感的小软件</title>
    <url>/2020/01/10/Window%E4%B8%8B%E6%8F%90%E5%8D%87%E6%B5%81%E7%95%85%E6%84%9F%E7%9A%84%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>记录一些好用的window下软件</p>
<h2 id="1-像浏览器一样打开你的文件夹-Clover"><a href="#1-像浏览器一样打开你的文件夹-Clover" class="headerlink" title="1.像浏览器一样打开你的文件夹-Clover"></a>1.像浏览器一样打开你的文件夹-Clover</h2><p>Clover，在Windows原生资源管理器的基础上加上类似Chrome的标签。Clover 把 Chrome 标签页有的样式、功能、右键菜单、快捷键全部移植，如果你常用Chrome浏览器，你应该能瞬间上手。</p>
<ul>
<li>你可以用Ctrl+T新开页面，Ctrl+W关闭页面，Ctrl+Tab切换页面，这和你使用Chrome浏览器是完全一样的！</li>
<li>Ctrl+D，（或者右键或者直接将文件夹拖入书签栏）可以添加当前路径到书签栏，常用的文件夹再也不用挨着打开文件夹找了！</li>
<li>鼠标滚轮点选文件夹时新建标签页</li>
<li>双击文件夹空白处跳到上层目录</li>
<li>双击标签标题时关闭当前标签页</li>
<li>在标签栏上使用鼠标滚轮来切换标签页<br>WIN10 建议用<a href="http://t.cn/Ai8YHRnK" target="_blank" rel="noopener">Clover3.5.2版</a>，WIN7 / XP 建议使用<a href="http://t.cn/Ai8YH0Cs" target="_blank" rel="noopener">Clover3.0.406版</a></li>
</ul>
<h2 id="2-透明任务栏–TranslucentTB"><a href="#2-透明任务栏–TranslucentTB" class="headerlink" title="2.透明任务栏–TranslucentTB"></a>2.透明任务栏–TranslucentTB</h2><p>注意，这款软件只支持Win10，在Microsoft store中可以免费获取。</p>
<h2 id="3-超快的文件搜索工具–everything"><a href="#3-超快的文件搜索工具–everything" class="headerlink" title="3.超快的文件搜索工具–everything"></a>3.超快的文件搜索工具–everything</h2><p>它还是一款完全免费的软件，界面简洁高效，软件大小只有不到2M，但功能却非常丰富。官网<a href="https://www.voidtools.com/zh-cn/downloads/" target="_blank" rel="noopener">直接下载</a>。</p>
<h2 id="4-系统清理与优化–系统优化加速工具"><a href="#4-系统清理与优化–系统优化加速工具" class="headerlink" title="4.系统清理与优化–系统优化加速工具"></a>4.系统清理与优化–系统优化加速工具</h2><p>由联想的高级工程师开发，无需解压，无需安装，下载即用。这个软件的清理功能一般，主要用来优化各种系统设置、系统服务项，所以一般只运行一次就行了。<a href="https://url.cn/5NxOByn" target="_blank" rel="noopener">下载地址</a></p>
<h2 id="5-革命性的搜索和应用启动软件–Listary"><a href="#5-革命性的搜索和应用启动软件–Listary" class="headerlink" title="5.革命性的搜索和应用启动软件–Listary"></a>5.革命性的搜索和应用启动软件–Listary</h2><p>与Everything类似，但是其功能更加适用于LabVIEW程序开发人员，或者常常与文件保存打开打交道的工作人员。无论何时何地，都可以连按两次 Ctrl 键来启动 Listary ，搜索你的应用和文件。非常方便，<a href="http://www.listary.com/download" target="_blank" rel="noopener">官网</a>即可下载。</p>
<h2 id="6-一些其他常用操作"><a href="#6-一些其他常用操作" class="headerlink" title="6.一些其他常用操作"></a>6.一些其他常用操作</h2><ul>
<li>常用快捷键：WIN+E打开 我的电脑</li>
<li>隐藏系统图标：桌面右键——「个性化」——「主题」——「桌面图标设置」。在隐藏回收站图标之前，先右键回收站图标——创建快捷方式——然后把快捷方式扔到你的快速启动目录中去</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>软件工具</tag>
      </tags>
  </entry>
  <entry>
    <title>断章</title>
    <url>/2020/01/08/%E6%96%AD%E7%AB%A0/</url>
    <content><![CDATA[<center>走一走，停一停</center>
]]></content>
      <tags>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>随想</title>
    <url>/2020/01/08/%E9%9A%8F%E6%83%B3/</url>
    <content><![CDATA[<p>关于经济形势<br>新的市场结构已经形成，旧的价值在衰退，不稳定性在增加并造成影响。</p>
<a id="more"></a>
<p>具体来说，中产阶层已经成为了市场中的消费主力，这对应着近来文娱的发展获利，中高端食品业的成功等等，其影响尚未达到峰顶，趋势仍在行进。旧有的许多产业已经达到高位，房地产，IT已经是维稳甚至下滑的阶段。生产过剩，债务泡沫，以及随之而来的劳动力过剩所造成的危机正在酝酿，国际上几乎所有国家都在沼泽上行走，等待着谁先沉没然后他者踩着它的尸体再多走一段。</p>
<p>就国内而言，可能的希望在于三个大区域（珠三角，长三角，北京区域）一体化的开发，新的技术革命的到来，新乡村新农业的开发（温铁军教授所言），最后国际形势的转变（其他国家倒下了，让出了地盘）。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>云服务器搭建私有云盘</title>
    <url>/2020/01/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98/</url>
    <content><![CDATA[<p>租了个云服务器，想着把它利用起来。先用它搭建个私有云盘吧。<br> <a id="more"></a> </p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>一个云服务器，如果是学生的话推荐阿里云学生服务器<a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云学生服务器</a>，9.5元一个月。<br>有两种，<a href="https://yq.aliyun.com/articles/700446" target="_blank" rel="noopener">区别参见</a>。<br>我是使用预装的centos系统。</p>
<h2 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2.搭建环境"></a>2.搭建环境</h2><p>在云服务器中搭建LAMP环境<a href="https://www.jianshu.com/p/fabe5842c0e1" target="_blank" rel="noopener">（Linux）</a>或者WNMP环境（windows）<br>预装包 </p>
<p><code>sudo yum install php-mysql php-json php-xml php-mbstring php-zip php-gd curl php-curl php-pdo</code></p>
<p>之后的操作都要在root权限下运行</p>
<h2 id="3-安装软件"><a href="#3-安装软件" class="headerlink" title="3.安装软件"></a>3.安装软件</h2><ul>
<li>获取压缩包。<pre><code>wget https://download.owncloud.org/community/owncloud-10.0.4.tar.bz2</code></pre></li>
</ul>
<ul>
<li>解压<pre><code>tar -xvf owncloud-10.0.4.tar.bz2</code></pre></li>
<li>将之移动到 /var/www/html<pre><code>mv owncloud/* /var/www/html </code></pre></li>
</ul>
<h2 id="4-修改配置Apache文件"><a href="#4-修改配置Apache文件" class="headerlink" title="4.修改配置Apache文件"></a>4.修改配置Apache文件</h2><ul>
<li><p>进入conf文件内        </p>
<pre><code>vim /etc/httpd/conf/httpd.conf</code></pre><p>修改AllowOverride none 为 AllowOverride All</p>
</li>
<li><p>更改权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R apache:apache /var/www/html/</span><br><span class="line">$ sudo chmod 777 /var/www/html/config/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Apache 服务器</p>
<pre><code>systemctl restart httpd</code></pre></li>
</ul>
<h2 id="5-在-MariaDB-上创建一个数据库，保存来自-OwnCloud-的数据"><a href="#5-在-MariaDB-上创建一个数据库，保存来自-OwnCloud-的数据" class="headerlink" title="5.在 MariaDB 上创建一个数据库，保存来自 OwnCloud 的数据"></a>5.在 MariaDB 上创建一个数据库，保存来自 OwnCloud 的数据</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">MariaDB [(none)] &gt; create database owncloud;</span><br><span class="line">MariaDB [(none)] &gt; GRANT ALL ON owncloud.* TO ocuser@localhost IDENTIFIED BY &apos;owncloud&apos;;</span><br><span class="line">MariaDB [(none)] &gt; flush privileges;</span><br><span class="line">MariaDB [(none)] &gt; exit</span><br></pre></td></tr></table></figure>

<h2 id="6-检验"><a href="#6-检验" class="headerlink" title="6.检验"></a>6.检验</h2><ul>
<li><p>服务器配置部分完成后，现在我们可以在网页浏览器上访问 OwnCloud。打开浏览器，输入您的服务器 IP 地址，之后按照步骤认证即可。类似下图。</p>
<p>  <img src="/2020/01/08/云服务器搭建私有云盘/0.png" alt></p>
</li>
<li><p>可能的问题：php版本过低请参照<a href="https://towait.com/blog/how-to-upgrade-php-version-54-to-56-on-cento7/" target="_blank" rel="noopener">https://towait.com/blog/how-to-upgrade-php-version-54-to-56-on-cento7/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>win10系统设置任务计划（以自动关机为例）</title>
    <url>/2020/01/08/win10%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%EF%BC%88%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>如何通过任务计划程序设置自动关机或者类似自动执行<br>可以设置单次任务，也可以设置长期执行的任务，适合设置有规律的关机计划。</p>
<a id="more"></a>
<h2 id="1-打开程序"><a href="#1-打开程序" class="headerlink" title="1 打开程序"></a>1 打开程序</h2><p>控制面板——管理工具——任务计划程序(也可以在开始菜单左下角的搜索程序和文件中输入“任务计划程序”来找到)，创建一个基本任务。</p>
<h2 id="2-按要求设置任务"><a href="#2-按要求设置任务" class="headerlink" title="2 按要求设置任务"></a>2 按要求设置任务</h2><p>输入名称，描述可以不写，进入下一步。<br>选择任务的执行频率，继续下一步。<br>在操作中，选择启动程序。<br>在程序或脚本一栏填入shutdown即可，同样参数可选择性填写。</p>
<h2 id="3-此时即可在列表中看见该任务"><a href="#3-此时即可在列表中看见该任务" class="headerlink" title="3  此时即可在列表中看见该任务"></a>3  此时即可在列表中看见该任务</h2>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>python 充分利用CPU</title>
    <url>/2020/01/07/python-%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8CPU/</url>
    <content><![CDATA[<p>当利用python处理大规模数据或者运行一些耗时较长的程序时，往往会发现程序运行时CPU并没有跑满，哪怕开了多线程后CPU利用率仍然不高。这是因为在默认情况下，Python 程序是单个进程，使用单 CPU 核心执行，这意味着多核处理器只使用了一个核。「一核有难九核围观」意味着超过 50% 的算力都会被浪费。这篇文章将介绍如何解决这种情况。</p>
<a id="more"></a>
<h2 id="多线程无法增加cpu使用率的原因"><a href="#多线程无法增加cpu使用率的原因" class="headerlink" title="多线程无法增加cpu使用率的原因"></a>多线程无法增加cpu使用率的原因</h2><p>GIL 的全程为 Global Interpreter Lock ，意即全局解释器锁。在 Python 语言的主流实现 CPython 中，GIL 是一个货真价实的全局线程锁，在解释器解释执行任何 Python 代码时，都需要先获得这把锁才行，在遇到 I/O 操作时会释放这把锁。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）。所以虽然 CPython 的线程库直接封装操作系统的原生线程，但 CPython 进程做为一个整体，同一时间只会有一个获得了 GIL 的线程在跑，其它的线程都处于等待状态等着 GIL 的释放。这就意味着哪怕开了多线程CPU使用率仍然不会很高。</p>
<h2 id="如何充分使用多核跑程序"><a href="#如何充分使用多核跑程序" class="headerlink" title="如何充分使用多核跑程序"></a>如何充分使用多核跑程序</h2><p>有三个办法</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p> multiprocessing 是多进程标准库，让多进程的 python 程序编写简化到类似多线程的程度，通过多进程的方式使用多个CPU核心。</p>
<h3 id="C-语言扩展机制"><a href="#C-语言扩展机制" class="headerlink" title="C 语言扩展机制"></a>C 语言扩展机制</h3><p>如果不想用多进程这样重量级的解决方案，可以改用 C/C++。当然，你也不用做的这么绝，只需要把关键部分用 C/C++ 写成 Python 扩展，其它部分还是用 Python 来写，让 Python 的归 Python，C 的归 C。一般计算密集性的程序都会用 C 代码编写并通过扩展的方式集成到 Python 脚本里（如 NumPy 模块）。这样在扩展里就完全可以用 C 创建原生线程，就可以充分利用 CPU 的计算资源了。</p>
<h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><p>不过，写 Python 扩展总是让人觉得很复杂。好在 Python 还有另一种与 C 模块进行互通的机制 : ctypes。ctypes 与 Python 扩展不同，它可以让 Python 直接调用任意的 C 动态库的导出函数。你所要做的只是用 ctypes 写些 python 代码即可。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>小白机器学习教程路线</title>
    <url>/2019/09/11/%E5%B0%8F%E7%99%BD%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="一-基础性知识可参照"><a href="#一-基础性知识可参照" class="headerlink" title="一 基础性知识可参照"></a>一 基础性知识可参照</h2><p><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers" target="_blank" rel="noopener">https://github.com/ZuzooVn/machine-learning-for-software-engineers</a>  自上而下的学习路径：软件工程师的机器学习/Top-down learning path: Machine Learning for Software Engineers<br><a href="https://github.com/imhuay/Algorithm_Interview_Notes-Chinese/tree/master/A-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener">https://github.com/imhuay/Algorithm_Interview_Notes-Chinese/tree/master/A-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0</a> 机器学习笔记/marchine learning note chinese</p>
<h2 id="二-kaggle-一个数据建模和数据分析竞赛平台"><a href="#二-kaggle-一个数据建模和数据分析竞赛平台" class="headerlink" title="二 kaggle (一个数据建模和数据分析竞赛平台)"></a>二 kaggle (一个数据建模和数据分析竞赛平台)</h2><p><a href="https://www.kaggle.com/learn/intro-to-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intro-to-machine-learning</a>  从kaggle网站中的教程中学习入门知识并实践<br>（这是一个很好的实践性教程，它可以帮助你了解一些核心的机器学习想法并帮助你建立一个机器学习模型，同时它的每一个章节都有可以在线编程的练习。最后，它导向一个很有趣的房价预测相关的比赛，这是开始kaggle的第一步。另外，如果想要在房价预测比赛中得到一个更好的结果，可以参照我的kernel（可以帮助你进入top4%）：<a href="https://www.kaggle.com/smith890/exercise-machine-learning-competitions）" target="_blank" rel="noopener">https://www.kaggle.com/smith890/exercise-machine-learning-competitions）</a><br><a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a>  泰坦尼克号：从灾难中学习机器/Titanic: Machine Learning from Disaster   </p>
<p>##待续</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个自己的博客（hexo+github）</title>
    <url>/2019/09/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1.序"></a>1.序</h2><p>第一篇博客就从怎么搭建的这个博客开始吧。</p>
<h2 id="2-环境配置与准备"><a href="#2-环境配置与准备" class="headerlink" title="2.环境配置与准备"></a>2.环境配置与准备</h2><p>所需要的：</p>
<ul>
<li>安装node.js（<a href="http://https://nodejs.org/en/" title="官网" target="_blank" rel="noopener">官网</a>下载安装即可）</li>
<li>安装git以及一个GitHub账号（如果不清楚请参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="廖雪峰git教程" target="_blank" rel="noopener">廖雪峰git教程</a>）</li>
<li>安装hexo（在已完成安装node.js的情况下，打开cmd 运行npm install -g hexo）</li>
</ul>
<h2 id="3-本地创建博客文件"><a href="#3-本地创建博客文件" class="headerlink" title="3.本地创建博客文件"></a>3.本地创建博客文件</h2><ul>
<li>新建一个存储博客文件的文件夹，例如MyBlog。</li>
<li>进入到这个文件夹内，运行git。在git bash内输入并运行 hexo init（生成博客模板）。生成完后，运行 npm install。</li>
<li>之后你的文件夹内就会生成标准的博客文件模板，文件结构如下：<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>其中：_config.yml： 其中我们以后的大部分操作都会在_config.yml中进行，这个文件是我们的站点的配置文件<br>　　　　scaffolds： 模板文件，规定了我们创建一篇文章的时候最开始的样子，<br>　　　　source： 可以暂时的理解成我们文章的存放处<br>　　　　themes： 主题文件存放处。</li>
<li>之后运行 hexo server 部署到本地，就可以访问本地<a href="http://localhost:4000/" title="localhost：4000" target="_blank" rel="noopener">localhost：4000</a>看见自己的博客</li>
</ul>
<h2 id="4-github中创建用于存放博客的仓库"><a href="#4-github中创建用于存放博客的仓库" class="headerlink" title="4.github中创建用于存放博客的仓库"></a>4.github中创建用于存放博客的仓库</h2><p>　　进入github新建repo，这里要注意repository的名字一定要满足UserName.github.io(这里的UserName是你GitHub账号的名字)。这样最后才能将这个仓库当作个人主页展示。</p>
<h2 id="5-关联本地博客文件夹和GitHub"><a href="#5-关联本地博客文件夹和GitHub" class="headerlink" title="5.关联本地博客文件夹和GitHub"></a>5.关联本地博客文件夹和GitHub</h2><ul>
<li>修改本地博客文件夹下_config.yml，找到最后的deploy部分。修改成：<pre><code>deploy:
    type: git
    repository: https://github.com/UserName/UserNamegithub.io.git
    branch: master</code></pre>其中：<br>　　type值对应的是你所部署的的服务器类型，我们这里填写git就可以。<br>　　repo是你的仓库地址，也就是仓库克隆的地址<br>　　branch不写默认是master，通常我们写成master就可以。<br>特别注意，冒号后需要空一格，例如type： git<br>完成上面的配置后，分别运行：<br>　　hexo clean       清理缓存<br>　　hexo generate 进行渲染 简写 hexo g<br>　　hexo deploy    简写为 hexo d来部署到git服务器<br>执行完后就可以打开浏览器地址，输入http://你github名字.github.io 看到效果了</li>
</ul>
<h2 id="6-开始写文章"><a href="#6-开始写文章" class="headerlink" title="6.开始写文章"></a>6.开始写文章</h2><ul>
<li>原生方式新建文章<br>Hexo的项目结构是在网站根目录的<code>source/_posts</code> 目录下存放你的博客文档，以.md文档格式存储，默认已存在一个hello-world.md文章<br>使用命令<code>hexo new &lt;title&gt;</code>创建文章，支持Markdown语法，也支持一些增强功能标签代码段，用于插入视频图片等。图片可以统一放在<code>source/images</code>目录中，并以<code>![](/images/image.jpg)</code>方式引用或者在<code>_config.yml</code> 打开 post_asset_folder 功能，将当前文章所用的图片放置到source目录下的文章同名资源目录下，以 <code>![](image.jpg)</code> 方式引用</li>
</ul>
<p>另外一些文章中提到建议使用第三方的专业图床来存放这些静态图片素材</p>
<ul>
<li>使用 Hexo Admin 插件<br>Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）<br><code>npm install --save hexo-admin</code> 安装<br><code>hexo server -d</code>  使用<br><code>open http://localhost:4000/admin</code>  </li>
</ul>
<h2 id="7-进阶"><a href="#7-进阶" class="headerlink" title="7.进阶"></a>7.进阶</h2><p>还想要进一步个性化或者增加其他小功能的朋友，推荐参考：</p>
<p><a href="http://yearito.cn/posts/hexo-advanced-settings.html" target="_blank" rel="noopener">Hexo 搭建个人博客系列：进阶设置篇</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p>
<p><a href="http://www.xinxiaoyang.com/programming/2016-11-25-hexo-image-bug/" target="_blank" rel="noopener">Hexo 图片插入</a><br>更多详细情况请参考官方文档（<a href="https://hexo.io/zh-cn/docs/" 官网"" target="_blank" rel="noopener">官网</a>）</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

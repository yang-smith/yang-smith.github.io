<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>断章</title>
    <url>/2222/01/01/%E6%96%AD%E7%AB%A0/</url>
    <content><![CDATA[<center>我降生，我死亡。</center>
<center>我追寻，我回望。</center>
]]></content>
      <tags>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>2020观察记录</title>
    <url>/2020/06/30/2020%E8%A7%82%E5%AF%9F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>时3月23日，有感今年将是数十年内最为精彩纷呈的一年，我将我所观察的形势状况，并附以思考，记录在此。</p>
<h2 id="3-24"><a href="#3-24" class="headerlink" title="3.24"></a>3.24</h2><ul>
<li>民众：美国疫情新增八千，恐慌加剧。英国宣布全国居家禁令。欧洲疫情总体稳步扩张。</li>
<li>经济：美国宣布无限QE，向金融市场注入资金（我暂且没想清楚后果，但只是印钱放水应该解决不了积弊多年的问题），金融分析者与民众普遍不看好经济前景，金融分析者认为当前已经近似于1927年大萧条。美股波动收降约3% 。</li>
<li>政治：中国主席向英国首相打电话探讨疫情，率先从疫情中恢复的中国通过防疫支援部分改善了外交环境。欧盟在我看来已经站在了悬崖边缘。<h2 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h2></li>
<li>民众：美国疫情日增一万，医疗资源陷入较大规模的紧缺。欧洲疫情继续扩张。其余地区的风险亦逐步扩大。越来越多国家宣布封锁。</li>
<li>经济：美国官方大放水，美股回升10%，但是市场预计任然悲观。欧盟及大部分国家都跟着放水刺激经济。巴西等产业国封锁，金银价格上升约6%。</li>
<li>政治：美国向韩国要求援助医疗设备，中国继续稳步进行疫情外交。<h2 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h2></li>
<li>民众：欧美疫情继续加剧。</li>
<li>经济：美股小幅回升，政府讨论2万亿财政政策。</li>
<li>政治：如常。<h2 id="3-27"><a href="#3-27" class="headerlink" title="3.27"></a>3.27</h2></li>
<li>民众：欧美疫情继续加剧。美国确诊超十万，英国首相感染。中国限制入境人口。</li>
<li>经济：美股小幅下降，政府通过2万亿财政政策。一些小型国家限制粮食出口，显示不好的征兆。</li>
<li>政治：如常。<h2 id="3-28-3-30"><a href="#3-28-3-30" class="headerlink" title="3.28-3.30"></a>3.28-3.30</h2></li>
<li>民众：欧美疫情继续加剧。日本奥运延期后加强力度治疫，可能封锁国境。中国的入境管控力度也在加大。</li>
<li>经济：印度及部分国家限制出口，全球化可能割裂。日本拟进行巨大经济刺激政策。</li>
<li>政治：地方主义抬头。<h2 id="4-3"><a href="#4-3" class="headerlink" title="-4.3"></a>-4.3</h2></li>
<li>民众：欧美疫情继续加剧。日本数字开始上涨，可能水面下已经非常严重。美国已经确定上千万人失业。</li>
<li>经济：全球化割裂加剧，美俄沙特围绕石油博弈加剧，美国第一家上市石油企业破产，风起惊雷。</li>
<li>政治：大致如常，经济的引领性增大。<h2 id="4-6"><a href="#4-6" class="headerlink" title="-4.6"></a>-4.6</h2></li>
<li>民众：欧美疫情继续加剧。日本宣布进入紧急状态。第三波疫情浪潮可能发生在印度与日本及第三世界国家。</li>
<li>经济：美俄沙特围绕石油博弈，美股缓跌，失业人数暴增。中国情绪上升。欧美债务问题迫近。欧洲银行可能会出现大问题。</li>
<li>政治：美国出现高价截断欧洲口罩等行为，英国首相新冠情况加重，入院治疗，女王发表讲话。<h2 id="4-14"><a href="#4-14" class="headerlink" title="-4.14"></a>-4.14</h2></li>
<li>民众：欧美疫情继续加剧。美国确诊超50万。疫情第三波浪潮也在来临，俄罗斯，印度，日本都走在通向深谷的路上。</li>
<li>经济：美俄沙特围绕石油博弈出了阶段性结果，三国同意减产，油价上升，但是美国页岩油危机并没有过去。西方各国央行政府大量扩充信贷，我认为这实质上是将企业与金融危机转嫁到了国家身上，提升了国家出现信用危机的概率。</li>
<li>政治：中美舆论战有加剧的苗头，中国在疫情中扩张着国际影响力。欧洲摇摇欲坠，英国在中美之间摇摆。<h2 id="4-16"><a href="#4-16" class="headerlink" title="-4.16"></a>-4.16</h2></li>
<li>民众：欧美疫情继续加剧。美国确诊超60万。美国在延长封锁与恢复经济之间摇摆。俄罗斯，印度，日本确诊人数上升飞快。</li>
<li>经济：石油谈判减产，但因为需求不足，价格仍然没有大幅回升。股市情绪出现稳定迹象，中国第一季度数据比预测数据好一点。日本进入紧急状态后面临严重的通缩危机。欧洲拟再次发行债务维护经济。美国部分零售业与服务业来到破产边缘。危机还没有真正降临，一个月还是两个月，变色风云。</li>
<li>政治：中美舆论战继续，在媒体传播上，中国处于劣势。美国内部两党之间的争斗愈发激烈，诸多矛盾浮出水面。</li>
</ul>
<h2 id="5-1"><a href="#5-1" class="headerlink" title="-5.1"></a>-5.1</h2><ul>
<li>民众：欧美疫情波动上升。美国确诊超百万。失业人口已达三千万，美国部分州进行或者考虑恢复生产。俄罗斯，印度，日本确诊人数上升飞快。</li>
<li>经济：石油期货交易出现负值。石油需求萎靡，供给仍然远大于需求。中美股市波动微升，中概由瑞幸开始出现危机，做空势力出现。国外资本部分流入国内金融市场，据我判断以欧洲资金为主。国内创业版改革注册制，中央政策倾向慢慢改良金融市场与扩大金融开放。日本与欧洲经济状况堪忧。一些零售业与航空业大公司申请破产。值得注意的是第一季度全球主要国家向市场注入了太多的货币/信贷，单美国就有至少10万亿美元，加之08年后本就泡沫化的全球市场，这让人担忧经济进入下个阶段后的剧烈通货膨胀。</li>
<li>政治：中美舆论战继续，美国政府试图转移矛盾给中国。民主共和两党开始为大选造势。韩国文在寅党权力巩固，日韩慢慢向中国靠拢。中国两会将在五月底召开，将决定之后数年的政策风向。</li>
</ul>
<h2 id="5-8"><a href="#5-8" class="headerlink" title="-5.8"></a>-5.8</h2><ul>
<li>民众：欧美疫情继续。英国状况严重，德意有所缓解。美国确诊超120万。在失业压力下，美国半数州已经复工。俄罗斯，印度，确诊人数上升飞快。中国以青年人为主体的反西方话语，新建中华的思潮有了苗头。</li>
<li>经济：美股已经完全与实业脱钩，美元泡沫越来越危险。世界性的大衰退无可避免。在经济不景气的时间内，社会矛盾逐渐显著。</li>
<li>政治：美国进入大选造势阶段，为了大选开始积极将矛盾引向中国。</li>
</ul>
<h2 id="6-4"><a href="#6-4" class="headerlink" title="-6.4"></a>-6.4</h2><ul>
<li>民情：疫情继续扩大，世界的大部分都受到影响。欧洲除开英国有所缓解。部分地区复工。美国确诊超190万。失业人口超2000万。东亚疫情整体可控，印度有失控迹象。疫情日久，人们对之开始麻木。五月末，美国黑人之死引爆社会矛盾，游行与暴动扩散。</li>
<li>经济：全球经济进入衰退周期。全球股市整体处于缓步回暖，但不知道有多少是货币超发的推动。中美割裂加剧，欧陆范围倒是可能联系更加紧密，中国谋求今年内签署中日韩自贸协定。</li>
<li>政治：国际政治大主体开始变为中美对抗。中美对抗逐步加剧，经贸领域小规模摩擦不断。中国两会召开，基本确定未来拉动内需，开发西部。</li>
</ul>
<h2 id="6-30"><a href="#6-30" class="headerlink" title="-6.30"></a>-6.30</h2><ul>
<li>民情：疫情在美洲大部分，印度次大陆部分持续持续扩张，而初始的爆发点东亚，欧洲等地基本得到控制。美国黑人运动缓解。</li>
<li>经济：经济方面暗流涌动但是没有明面上的大事。中美股市持续复苏。中印摩擦加剧，印度出台法律限制中国互联网势力。</li>
<li>政治：美国进入大选状态，中美矛盾暂时缓和，中印摩擦又起。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之查找</title>
    <url>/2020/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>查找是在大量的信息中寻找一个特定的信息元素。面对查找问题，常用的算法有以下四种：</p>
<ul>
<li>线性查找</li>
<li>二分查找</li>
<li>插值插值</li>
<li>斐波那契查找</li>
</ul>
<p>下面说明皆以数组查找为例。</p>
<h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><p>线性查找是最为质朴的查找方式，思想就是遍历每一个元素直到找出目标值。</p>
<h3 id="二分（折半）查找"><a href="#二分（折半）查找" class="headerlink" title="二分（折半）查找"></a>二分（折半）查找</h3><p>二分查找是应用的非常广泛的查找方式，其需要所查找的数据集是有序的。思路是先将数组二分，比较目标值与数据集中间值大小，以确定目标值在数组二分后的哪个部分，而后再将这个部分二分，将目标值与中间值相比较，确定目标值在二分后的哪一块，如此不断进行直到找到目标值。</p>
<p>二分查找的效率非常高。这种高效率需要数据本身有序为基础，有序数据相比杂乱数据本身包含了更多的信息（或者说信息熵更低），二分查找便是利用了这部分信息。</p>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>插值查找是二分查找的改进。其改进之处在于中间值的选择。插值查找中间值由公式：mid = low + (key - a[low])/(a[high] - a[low]) * (high - low)。其中mid即为中间值，low为左索引，high为右索引，key为目标值，a为数组。这种方法下，中间值是自适应变化的。</p>
<p>当数据量较大，关键字分布均匀时，这种方法比二分查找效率更高。根本原因在于其同时利用了目标值本身的信息。</p>
<h3 id="斐波那契（黄金分割法）查找"><a href="#斐波那契（黄金分割法）查找" class="headerlink" title="斐波那契（黄金分割法）查找"></a>斐波那契（黄金分割法）查找</h3><p>斐波那契查找思想基于黄金分割点与斐波那契数列，也是对二分查找的改进。与插值查找类似，其想法也是在改变中间值的选取。斐波那契查找通过斐波那契数列使得每次取的中间值接近于黄金分割点。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法学习思考记录</title>
    <url>/2020/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>以我对于数据结构与算法的思考，数据结构根本上是数据的组织形式，不同的组织形式有不同的特性可以利用。算法是解决特定问题的程式，实际使用中往往以数据结构为基础。所以两者通常捆绑在一起学习。</p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h4 id="算法复杂度问题"><a href="#算法复杂度问题" class="headerlink" title="算法复杂度问题"></a>算法复杂度问题</h4><p>算法复杂度是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。时间资源对应时间复杂度，内存资源 对应空间复杂度。通常我们需要通过确定的复杂度来衡量算法的好坏。一般讨论复杂度都是最坏情况下的复杂度。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>基本的数据结构可分为线性结构与非线性结构<br>线性结构包括数组，链表，队列，栈。<br>非线性结构包括：树，图。</p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>最为常用的数据结构莫过于数组。 值得一提的是稀疏数组可以压缩存储。</p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈( Stack)"></a>栈( Stack)</h4><p>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。<br>比较经典的栈使用在于底层的现场保护，表达式计算中的中缀转后缀。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h4><p>与栈类似，不过规则变为先进先出。<br>队列在一些排队等待之类的问题中常用。特殊一些的有循环队列。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表特殊之处在于由指针链接其他元素。这也使得其增改非常方便。很多算法便是利用了这一特性，例如约瑟夫问题。</p>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><h4 id="哈希表-散列表（Hash）"><a href="#哈希表-散列表（Hash）" class="headerlink" title="哈希表/散列表（Hash）"></a>哈希表/散列表（Hash）</h4><p>哈希表根据关键码值访问数据。 python中的字典就是根据哈希表的原理实现。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树里面二叉树是基础。其遍历方式分为前序查找，中序查找，后序查找。<br>二叉树比较经典的有在于使用大顶堆，小丁堆为基础的堆排序与使用霍夫曼树为基础的霍夫曼压缩。<br>在数据存储方面，一般使用二叉排序树（BTS）与平衡二叉树（AVL）。存放有序的数据，相比于数组与链表，其增加与查找的效率都比较高，删除相对麻烦。</p>
<p>在多叉树中非常重要的即为B树。B树广泛的使用在文件存储系统与数据库系统中。很多数据库（例如mysql）的索引便是基于B树或者B+树。</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>一般面对多对多关系的时候我们使用图这种数据结构。其在存储方式有两种：由数组实现的邻接矩阵与由链表实现的邻接表。遍历与查找方式也分为两种：深度优先与广度优先。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>解决重复问题，并且下一次重复使用上一次重复的部分结果。同时也是分治，动态规划之类算法实现的基础。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。许多复杂的，规模较大的问题都可以使用回溯法。对于迷宫类问题，马踏棋盘问题，八皇后问题等有着很好的应用。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>对数据进行排序是一个泛性的问题，不同排序算法影响着排序的效率。对此我将单开一章进行叙述。</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><p>在数据集中查找某个数据也是基础性的问题，与排序类似，也单开一章叙述。</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治与下面的动态规划，贪心算法在我看来都可以分为一类，同属于复杂问题的解决思路。分治的思路为：将复杂问题不断分解为独立的简单小问题，解决小问题后再将结果合并得到复杂问题的解。关键即在于如何划分，如何合并。<br>常见的应用就是汉诺塔问题。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划的思路为：复杂问题是由小问题一步步扩展来的。所以解决基础问题然后利用已得的解解决复杂一些的问题，一步步向外扩展最终得到复杂问题的解。比较经典的应用即为背包问题。</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法思路为：在问题的每一步优先选择当前最优解，最终得到复杂问题的近似最优解。</p>
<h3 id="字符串匹配KMP算法"><a href="#字符串匹配KMP算法" class="headerlink" title="字符串匹配KMP算法"></a>字符串匹配KMP算法</h3><p>KMP算法是一种比较高效率的字符串算法。思路是在暴力匹配的基础上使用一个部分匹配表控制指针后移。</p>
<h3 id="最小生成树问题算法（Prim与Kruskal）"><a href="#最小生成树问题算法（Prim与Kruskal）" class="headerlink" title="最小生成树问题算法（Prim与Kruskal）"></a>最小生成树问题算法（Prim与Kruskal）</h3><p>应对在连通图里面寻找最小生成树的问题，常用的有Prim算法与kruskal算法。</p>
<ul>
<li>Prim算法。其以贪心算法为基础，将图分为已经确定的部分与未确定部分然后不断寻找连接最优解。</li>
<li>kruskal算法。也是贪心算法为基础，将图的边长的排序，不断取出最小值进行判断，直至问题解决。</li>
</ul>
<h3 id="图的最短路径算法（Dijkstra与Floyd）"><a href="#图的最短路径算法（Dijkstra与Floyd）" class="headerlink" title="图的最短路径算法（Dijkstra与Floyd）"></a>图的最短路径算法（Dijkstra与Floyd）</h3><p>如何得到图中一点到另一点的最短路径，常用的有两种算法。</p>
<ul>
<li>迪杰斯特拉(Dijkstra)算法。其以贪心与动态规划算法为基础，列出起点到各个点最短路径表最终解决问题。</li>
<li>弗洛伊德（Floyd）算法。其以动态规划为基础，以邻接矩阵记录图中两点最短距离，不断更新这个邻接矩阵直至得到完整的最短路径表。</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之排序问题</title>
    <url>/2020/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>排序问题是基础的算法问题<br>按照是否通过比较来决定次序分为比较类与非比较类两类<br>比较类排序算法，需要复合次比较才能确定次序，所以时间复杂度不会低于O（nlogn）。<br>而非比较类则可以突破比较类的时间界限，以线性时间运行。<br>比较类下面细分又有：交换（冒泡，快排），插入（简单插入，希尔），选择（简单选择，堆），归并（二路归并，多路归并）排序<br>非比较类则包含：计数，桶，基数排序</p>
<p>下文默认数组包含n个数，升序排列。</p>
<h2 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h2><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><ul>
<li>冒泡排序<br> 冒泡排序思路在于想气泡从水底浮上来一样，将数值大的数不断向后交换。一趟确定一个大数的次序，两层for循环，时间复杂度为O（n^2）。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mPao(int[] nums,int n )&#123;</span><br><span class="line">    //冒泡排序 </span><br><span class="line">    int temp;</span><br><span class="line">    boolean flag; //标志符：代表这一趟排序是否没有元素变动</span><br><span class="line">    for(int i = 0;i &lt; n-1;i++)&#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        for(int j = 0;j&lt;n - i -1;j++)&#123;</span><br><span class="line">            if(nums[j]&gt;nums[j+1])&#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+1];</span><br><span class="line">                nums[j+1] = temp;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li>快速排序<br>  快速排序是对冒泡排序的改进。冒泡排序的问题在于太慢，不断的交换消耗很多时间。快速排序进行选择性的交换，先将数组分成两部分，大的数归在一边，小的数归在另一边。然后在两边再分别进行快速排序。这里在代码层面用上了递归的思想。最坏情况时间复杂度O（ n^2）。但是平均时间复杂度有所降低为O（nlogn）。一般情况要比冒泡快。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QuickSort(int[] nums,int low,int high,int n)&#123;</span><br><span class="line">    if(low &lt; high)&#123;</span><br><span class="line">        int pivotpos = partition(nums,low,high);</span><br><span class="line">        QuickSort(nums,low,pivotpos-1,n);</span><br><span class="line">        QuickSort(nums,pivotpos+1,high,n);            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int partition(int[] nums,int low,int high)&#123;</span><br><span class="line">    int pivot = nums[low];  //中轴</span><br><span class="line">    while(low &lt; high)&#123;</span><br><span class="line">        while(high &gt; low &amp;&amp; nums[high] &gt;= pivot) high--;</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        while(low &lt; high &amp;&amp; nums[low] &lt;= pivot) low++;</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li><p>简单插入排序<br>插入排序想法是将数组分为有序无序，不断从无序部分取数然后按照大小插入到有序部分的合适位置。时间复杂度O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void insertSort(int[] nums,int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        int j = i-1;</span><br><span class="line">        while(j &gt;= 0 &amp;&amp; nums[j] &gt; temp) &#123;  //将插入位置后面的数依次后移</span><br><span class="line">            nums[j+1] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序<br>希尔排序是插入排序的改进。它的不同之处在于先比较距离较远的数。算法思想在于将距离较远的数划分为一组，对每组进行插入排序。逐渐缩小划组距离直至距离为1。希尔排序快速的原因就在于较远距离分组排序，这样每一次分组排序都是模糊的将偏小的数排到左侧，实现上没有类似简单插入排序中插入后移这样耗费时间的步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(int[] nums,int n)&#123;</span><br><span class="line">    for(int dk = n/2;dk&gt;=1;dk=dk/2)&#123;  // 按步长分组</span><br><span class="line">        for(int i=dk;i&lt;n;++i) &#123;</span><br><span class="line">            if(nums[i]&lt;nums[i-dk])&#123;</span><br><span class="line">                int tmp = nums[i],j;</span><br><span class="line">                for(j = i-dk;j&gt;=0&amp;&amp;tmp&lt;nums[j];j-=dk)&#123;</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j+dk]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的基本思想就是分治策略。</p>
<ul>
<li>两路归并<br>  将数组不断的二分，直到都是两个为一组。对底层的每一组排序，再将之向上边排序边组合，一直组合到最上层得到有序数组。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mergeSort(int[] nums,int bgn,int end)&#123;</span><br><span class="line">    if(bgn &gt;= end) return;</span><br><span class="line">    int mid = (bgn+end)/2 ;</span><br><span class="line">    mergeSort(nums,bgn,mid); //二分</span><br><span class="line">    mergeSort(nums,mid + 1,end);</span><br><span class="line">    merge(nums,bgn,mid,end); //重组</span><br><span class="line">&#125;</span><br><span class="line">void merge(int[] nums,int bgn,int mid,int end)&#123;</span><br><span class="line">    int[] temp = new int[end - bgn +1];</span><br><span class="line">    int l = bgn,m = mid +1;</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(k = 0;k &lt; temp.length;k++)&#123;</span><br><span class="line">        if(l &gt; mid)&#123;</span><br><span class="line">            temp[k] = nums[m];</span><br><span class="line">            m++;                </span><br><span class="line">        &#125;</span><br><span class="line">        else if(m &gt; end)&#123;</span><br><span class="line">            temp[k] = nums[l];</span><br><span class="line">            l++;                </span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[l]&lt;nums[m])&#123;</span><br><span class="line">            temp[k] = nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;                 </span><br><span class="line">        else &#123;</span><br><span class="line">            temp[k] = nums[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i &lt; temp.length;i++)&#123;</span><br><span class="line">        nums[i + bgn] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li><p>简单选择排序<br>  思路很简单，即选择最小的与数组第一位交换，然后选择除开有序的其余部分最小的与数组第二位交换……直到最后数组有序。时间复杂度O(n^2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void selectSort(int[] arr)&#123;</span><br><span class="line">    int min;</span><br><span class="line">    for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for(int j = i;j&lt;arr.length;j++)&#123;</span><br><span class="line">            if(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min != i) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排序<br>  堆排序依托于二叉树中名为堆的数据结构。用数组变化模拟堆变化。思路在于，建立大顶堆，而后将堆顶（即最大值）放到数组末尾，对其余部分再重建大顶堆，再将堆顶放到数组尾部，这样得到次大值，不断重复操作直至数组有序。时间复杂度O(nlogn)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void heapSort(int[] nums) &#123;</span><br><span class="line">    int size = nums.length;</span><br><span class="line">    for (int i = size/2-1; i &gt;=0; i--) &#123;</span><br><span class="line">        adjust(nums, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = size - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">        int temp = nums[0];</span><br><span class="line">        nums[0] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        adjust(nums, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void adjust(int []nums, int len, int index) &#123;</span><br><span class="line">    int l = 2 * index + 1;</span><br><span class="line">    int r = 2 * index + 2;</span><br><span class="line">    int maxIndex = index;</span><br><span class="line">    if (l&lt;len&amp;&amp;nums[l]&gt;nums[maxIndex])maxIndex = l;</span><br><span class="line">    if (r&lt;len&amp;&amp;nums[r]&gt;nums[maxIndex])maxIndex = r;</span><br><span class="line">    if (maxIndex != index) &#123;</span><br><span class="line">        int temp = nums[maxIndex];</span><br><span class="line">        nums[maxIndex] = nums[index];</span><br><span class="line">        nums[index] = temp;</span><br><span class="line">        adjust(nums, len, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序针对整数数组，想法在于另外开辟一个数组空间，新数组代表一个顺序序列，数组每个位置代表一个数值。遍历等待排序的数组，出现一个数值就将新数组对应位置加一。结束后再遍历新数组，按次序将各个部分代表的数值输出，得到结果。以牺牲空间为代价可以获得线性的时间复杂度。在n不算太大时非常有效。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的改进。其限制了开辟空间的大小。基本想法在于将数组按大小分组，就像是将数值分别投入不同的桶内（桶是有大小顺序的）。然后桶内部排序，排完后再按照桶的排序状况取出。包含一定的分治思想。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bucketSort(int[] nums)&#123;</span><br><span class="line">     int[] bk = new int[2*50000+1];</span><br><span class="line">     for(int i = 0;i &lt; nums.length;i++)&#123;</span><br><span class="line">         bk[nums[i]+50000] += 1;</span><br><span class="line">     &#125;</span><br><span class="line">     int index = 0;</span><br><span class="line">     for(int i = 0;i &lt; bk.length;i++)&#123;</span><br><span class="line">         for(int j = bk[i];j &gt; 0;j--)&#123;</span><br><span class="line">             nums[index++] = i - 50000;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>其想法在于，按位排序。先按个位桶排序，再按十位桶排序，再按百位桶排序……直到最高位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void countSort(int[] arr,int n)&#123;</span><br><span class="line">    int[] bk = new int[19];</span><br><span class="line">    Integer max = Integer.MIN_VALUE;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(max &lt; Math.abs(arr[i])) max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(max &lt; 0) max = -max;</span><br><span class="line">    max = max.toString().length();       //求最高有几位 </span><br><span class="line">    </span><br><span class="line">    int [][] bd = new int[19][arr.length];</span><br><span class="line">    for(int k = 0; k &lt; 6; k++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int value = (int)(arr[i] / (Math.pow(10,k)) % 10);</span><br><span class="line">            bd[value+9][bk[value+9]++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int fl = 0;</span><br><span class="line">        for(int l = 0; l &lt; 19; l++)&#123;</span><br><span class="line">            if(bk[l] != 0)&#123;</span><br><span class="line">                for(int s = 0; s &lt; bk[l]; s++)&#123;</span><br><span class="line">                    arr[fl++] = bd[l][s];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bk = new int[19];</span><br><span class="line">        fl = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java框架Spring boot 学习</title>
    <url>/2020/05/10/Java%E6%A1%86%E6%9E%B6Spring%20boot%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>时间紧迫，在学完Java基础部分，了解一些前端知识，一点MVC构架，Maven功能后，直接进行了Spring boot的学习，这是这篇博客的背景。</p>
<h2 id="一-搭建一个基础的Springboot项目"><a href="#一-搭建一个基础的Springboot项目" class="headerlink" title="一 搭建一个基础的Springboot项目"></a>一 搭建一个基础的Springboot项目</h2><h4 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h4><p>你可以通过 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 这个网站来生成一个 Spring Boot 的项目。注意勾选上 Spring Web 这个模块，这是我们所必需的一个依赖。当所有选项都勾选完毕之后，点击下方的按钮 Generate 下载这个 Spring Boot 的项目。下载完成并解压之后，我们直接使用 IDEA 打开即可。</p>
<p>也可以直接通过 IDEA 来生成一个 Spring Boot 的项目，具体方法和上面类似：File-&gt;New-&gt;Project-&gt;Spring Initializr。</p>
<blockquote>
<p>注意如果使用的是免费版的IDEA community的话，需要先安装 Spring Assistant 插件，然后新建项目通过 Spring Assistant 建立Springboot项目。</p>
</blockquote>
<h4 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h4><p><img src="/2020/05/10/Java框架Spring boot 学习/software/%E6%9C%89%E9%81%93%E4%BA%91%E6%9C%AC%E5%9C%B0/Springboot.png" alt><br>以 Application为后缀名的 Java 类一般就是 Spring Boot 的启动类，比如本项目的启动项目就是HelloWorldApplication 。我们直接像运行普通 Java 程序一样运行它，由于 Spring Boot 本身就嵌入servlet容器(tomcat等)的缘故，我们的 web 项目就运行成功了。<br>一般的项目结构类似以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- domain</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |  </span><br><span class="line">      | +- config</span><br><span class="line">      |  +- swagerConfig.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure>

<ol>
<li>Application.java是项目的启动类</li>
<li>domain目录主要用于实体（Entity）与数据访问层（Repository）</li>
<li>service 层主要是业务类代码</li>
<li>controller 负责页面访问控制</li>
<li>config 目录主要放一些配置类</li>
</ol>
<h4 id="开始例行-Hello-world-的编写"><a href="#开始例行-Hello-world-的编写" class="headerlink" title="开始例行 Hello world 的编写"></a>开始例行 Hello world 的编写</h4><p>新建controller文件夹，新建名为HelloWorldController的类，主体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/test&quot;)</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，浏览器访问 <a href="http://localhost:8080/test/hello" target="_blank" rel="noopener">http://localhost:8080/test/hello</a>  。页面中出现Hello World 即运行成功。</p>
<h2 id="基础内容学习"><a href="#基础内容学习" class="headerlink" title="基础内容学习"></a>基础内容学习</h2><p>待续。。。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java自学资源推荐</title>
    <url>/2020/04/26/Java%E8%87%AA%E5%AD%A6%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>首推：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a> </p>
<p>一份java学习面试基础指南，涵盖Java程序员所需要掌握的核心知识。最重要的推荐里面的学习路线，对于准备开始学习者非常有益处。</p>
<p><a href="https://how2j.cn/" target="_blank" rel="noopener">how2j Java自学网站</a></p>
<p>这个网站里每个知识点都被拆成小块进行学习，重要的是每一部分都有对应的小练习。</p>
<p><a href="https://github.com/Snailclimb/awesome-java#%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">github开源项目推荐</a></p>
<p>包含了各种门类的开源项目，有基础性的有进阶，适合学习了一段时间后自己动手实践。</p>
<p>电子书籍：<a href="https://lingcoder.github.io/OnJava8/#/sidebar" target="_blank" rel="noopener">OnJava8中文版</a></p>
<p>持续更新中。。。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>中国房地产整体状况的分析与判断</title>
    <url>/2020/04/08/%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%95%B4%E4%BD%93%E7%8A%B6%E5%86%B5%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>房地产/房屋在生活中占据着重要的位置，国内的房地产一直为人诟病，争论不休。整个房地产行业在改革开放后至现在是资产膨胀最为剧烈。房产价格的核心我认为是 供需 政府政策 群众心理 三个方面。我们先以此分析过去的房产价格：</p>
<p>供需是最为基础的价格支撑，过去城市房价飞升的最基本的驱动力是不断向城市汇集的人口。在人口结构上，新中国以来的大致以二十年为间隔的三波婴儿潮，持续推动着购房需求。需求的旺盛，提供了价格的地基。</p>
<p>政府政策方面显得复杂的多。过去的时间内，无论政府有意无意，土地财政确实吸纳了普通劳动者的部分劳动所得而成为国家能够集中力量办大事的经济基础。在这种土地财政的驱使下，房屋的供给长时间内小于需求，从而拔高了房产价格。</p>
<p>群众心理部分则更加复杂。房产对于绝大部分人是必需品，是所谓“刚需”，这部分社会心理加上基础人口构成需求的最底层。房产在过去的长时间内是社会群众心理上的推崇甚至评判资产，这刺激着很多人在满足了一套房产的需求后，会接着追求第二套房产或者更大更好的房产。这样的群众心理或者说社会风气又提供了坚实的中层需求。再往上的地产商的运作，资本的操纵，了解不多，不予置评。</p>
<p>当然，除此三种还有很多的影响因素，但是那些庞杂的因素大多不能满足广泛性与长期性的要求，所以不入其中。</p>
<p>在这种分析的基础上，尝试性的预测未来的趋势。<br>供需：供需在今年，2020，已经实质上到达了转折点。一是城市人口净流入萎缩，一线大城市的扩张进入由量转质的新阶段。二是人口结构上，第三波婴儿潮下的人口大多已经购置完房产，第四波由开放生育带来的婴儿潮在数量上与前三次相差甚远。这意味着需求的持续性萎缩。最危险的时刻在于第二波婴儿潮下人口到达退休年龄后，也就是2025年后，这波人是现在持有房产最多的人群，到那时供需将彻底的逆转。</p>
<p>政府政策：土地财政仍在实行，但已然显露出诸多问题，随着经济增速下行，财政特别是地方财政尤为吃紧。国家急需另一个财政来源，改革是必然的事情。同时房产市场已经出现泡沫化危机，疫情下进行经济刺激，地方财政压力等等多因素影响下，整体的政府政策大概率会进入比较复杂的阶段。等待今年的两会，可能会露出风向。</p>
<p>群众心理：为什么说这是最为复杂的，社会心理或社会风气的转变常常是潜移默化的，当人们意识到时都是已经到了成型的阶段。底层的需求一直在，但中层的需求已经发生了变化。人心难测，我仅聊一聊稍微熟悉一些的，未来的购房主力，年轻人。这一代的年轻人更重视生活的质量，他们相较于上一辈的愿意为房产付出巨大代价的意愿是可见的降低。另外在他们买房时很多是有二套房的上一代卖房来筹集资金，一房换一房，这意味着不对供需造成大影响。而在市场方面，资本方无疑有是刺激群众买房的动力，也有着诸多市场化的刺激手段。</p>
<p>总体来说，房产市场价格有着较大的下行压力，对社会最好的不过是在通胀下面一点的均线上波动。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>python界面开发（GUI）实现</title>
    <url>/2020/03/08/python%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%88GUI%EF%BC%89%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="选择GUI库"><a href="#选择GUI库" class="headerlink" title="选择GUI库"></a>选择GUI库</h1><p>&#160; &#160; &#160;常见的支持python图形界面编程的模块包括：<strong>PyQt、PySide、PySide2、wxPython、Tkinter</strong>。<br><br>&#160; &#160; &#160;wxPython、Tkinter模块界面丑功能少不考虑使用。现今使用最为广泛的PyQt，其作为Python编程语言和Qt库的成功融合，功能强大界面美观，社区活跃，但是存在着版权问题（科研学术能够免费使用，商业开发则需要购买许可证），所以选用与PyQt类似的Pyside2进行开发。另外提一句，Pyside与Pyside2区别在于，Pyside支持python2，Pyside2支持python3。</p>
<h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>这是为了最后软件打包时的考虑，新的虚拟环境只安装必要的模块，这样最后打包时不会因为打包进额外的模块或库而变的过大。</p>
<h3 id="Anaconda下虚拟环境相关操作："><a href="#Anaconda下虚拟环境相关操作：" class="headerlink" title="Anaconda下虚拟环境相关操作："></a>Anaconda下虚拟环境相关操作：</h3><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><ul>
<li>查看当前存在哪些虚拟环境<br><code>conda env list</code> 或 <code>conda info -e</code> </li>
<li>查看安装了哪些包<br><code>conda list</code> </li>
<li>检查更新当前conda<br><code>conda update conda</code> <h4 id="虚拟环境操作"><a href="#虚拟环境操作" class="headerlink" title="虚拟环境操作"></a>虚拟环境操作</h4></li>
<li>创建新的虚拟环境<br><code>conda create -n your_env_name python=X.X（2.7、3.6等)</code>    </li>
<li>使用如下命令即可激活你的虚拟环境(即将python的版本改变)。<br><br>  linux:  <code>activate your_env_name(虚拟环境名称)</code><br><br>  Windows:  <code>activate your_env_name(虚拟环境名称)</code></li>
<li>安装package到your_env_name中<br><code>conda install -n your_env_name [package]</code></li>
<li>退出环境<br><code>source deactivate</code>    </li>
<li>即可删除虚拟环境<br><code>conda remove -n your_env_name(虚拟环境名称) --all</code> </li>
<li>删除环境中的某个包<br><br><code>conda remove --name your_env_name  package_name</code>  </li>
<li>检查当前python的版本<br><br><code>python --version</code></li>
</ul>
<h1 id="安装与使用PySide2"><a href="#安装与使用PySide2" class="headerlink" title="安装与使用PySide2"></a>安装与使用PySide2</h1><p>推荐教程 <br><br><a href="https://github.com/se7enXF/pyside2" target="_blank" rel="noopener">Python爱好者的Qt入门手册</a><br><br><a href="https://zhuanlan.zhihu.com/p/75637361" target="_blank" rel="noopener">使用PySide2开发GUI</a><br><br><a href="https://www.qt.io/cn/qt-for-python" target="_blank" rel="noopener">官方文档</a><br><br><a href="https://zmister.com/archives/category/guidevelop/" target="_blank" rel="noopener">州的先生博客</a></p>
<blockquote>
<p>补充：PySide包可以预先去<a href="http://download.qt.io/snapshots/ci/pyside/下载，再用pip安装。" target="_blank" rel="noopener">http://download.qt.io/snapshots/ci/pyside/下载，再用pip安装。</a><br><br>从.ui生成.py文件：<code>pyside2-uic [你保存的文件名].ui &gt; ui_mainwindow.py</code></p>
</blockquote>
<h1 id="使用过程中遇到的问题"><a href="#使用过程中遇到的问题" class="headerlink" title="使用过程中遇到的问题"></a>使用过程中遇到的问题</h1><h4 id="1-教程不详细，问题难解决"><a href="#1-教程不详细，问题难解决" class="headerlink" title="1.教程不详细，问题难解决"></a>1.教程不详细，问题难解决</h4><p>pyside2与PyQt极为相似，可以通过PyQt教程学习pyside的使用方法，搜索PyQt的类似问题来解决pyside使用过程中遇到的问题</p>
<h4 id="2-qt-designer中预览与实际程序运行不符"><a href="#2-qt-designer中预览与实际程序运行不符" class="headerlink" title="2.qt designer中预览与实际程序运行不符"></a>2.qt designer中预览与实际程序运行不符</h4><p>在<code>app = QtWidgets.QApplication(sys.argv)</code>之前，加上<code>QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)</code></p>
<h4 id="3-程序运行中界面无响应"><a href="#3-程序运行中界面无响应" class="headerlink" title="3.程序运行中界面无响应"></a>3.程序运行中界面无响应</h4><p>很可能是后台进行的函数阻塞了界面刷新，尝试多线程/多进程的方式分开界面与后台。</p>
<h2 id="图形界面中数据可视化（绘制折线图等）"><a href="#图形界面中数据可视化（绘制折线图等）" class="headerlink" title="图形界面中数据可视化（绘制折线图等）"></a>图形界面中数据可视化（绘制折线图等）</h2><p>参考：<a href="https://zmister.com/archives/187.html" target="_blank" rel="noopener">Python GUI教程（十三）：在GUI中使用pyqtgraph绘图库</a><br><a href="https://www.jb51.net/article/136397.htm" target="_blank" rel="noopener">Python使用matplotlib绘图无法显示中文问题的解决方法</a><br><a href="https://blog.csdn.net/panrenlong/article/details/80183519?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">在PyQt5设计的GUI界面中显示matplotlib绘制的图形</a><br><a href="https://wingsgo.github.io/2018/10/10/matplotlib-embedded.html" target="_blank" rel="noopener">在PySide2中嵌入matplotlib</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活】改善睡眠</title>
    <url>/2020/03/08/%E3%80%90%E7%94%9F%E6%B4%BB%E3%80%91%E7%9D%A1%E7%9C%A0/</url>
    <content><![CDATA[<blockquote>
<p><em>参考：斯坦福高效睡眠法</em> <br> <a href="https://www.bilibili.com/video/av47071593" target="_blank" rel="noopener"><em>斯坦福高效睡眠法，带你摆脱失眠之苦</em></a><br></p>
</blockquote>
<p><strong>黄金睡眠时间是入睡后的90分钟</strong><br>现代人常常因为生物钟紊乱而受到睡眠不良的困扰，睡眠不良又影响整体工作学习状态，我将我所了解到的睡眠建议记录如下。</p>
<h1 id="睡眠建议"><a href="#睡眠建议" class="headerlink" title="睡眠建议"></a>睡眠建议</h1><h2 id="1-睡前90分钟洗澡，前60分钟淋浴，睡前足浴"><a href="#1-睡前90分钟洗澡，前60分钟淋浴，睡前足浴" class="headerlink" title="1.睡前90分钟洗澡，前60分钟淋浴，睡前足浴"></a>1.睡前90分钟洗澡，前60分钟淋浴，睡前足浴</h2><h2 id="2-睡前保持单调无聊的状态"><a href="#2-睡前保持单调无聊的状态" class="headerlink" title="2.睡前保持单调无聊的状态"></a>2.睡前保持单调无聊的状态</h2><h2 id="3-在床上专注睡觉（不在床上玩手机，或者做其他事情）"><a href="#3-在床上专注睡觉（不在床上玩手机，或者做其他事情）" class="headerlink" title="3.在床上专注睡觉（不在床上玩手机，或者做其他事情）"></a>3.在床上专注睡觉（不在床上玩手机，或者做其他事情）</h2><h2 id="4-形成规律作息，从固定起床时间开始，再确定入睡时间"><a href="#4-形成规律作息，从固定起床时间开始，再确定入睡时间" class="headerlink" title="4.形成规律作息，从固定起床时间开始，再确定入睡时间"></a>4.形成规律作息，从固定起床时间开始，再确定入睡时间</h2><h2 id="5-睡前不看屏幕，避免看蓝光（可以开原彩显示True-tone以及夜览Night-Shift）"><a href="#5-睡前不看屏幕，避免看蓝光（可以开原彩显示True-tone以及夜览Night-Shift）" class="headerlink" title="5.睡前不看屏幕，避免看蓝光（可以开原彩显示True tone以及夜览Night Shift）"></a>5.睡前不看屏幕，避免看蓝光（可以开原彩显示True tone以及夜览Night Shift）</h2><h2 id="6-必须熬夜时先睡100分钟（黄金90分钟原理）"><a href="#6-必须熬夜时先睡100分钟（黄金90分钟原理）" class="headerlink" title="6.必须熬夜时先睡100分钟（黄金90分钟原理）"></a>6.必须熬夜时先睡100分钟（黄金90分钟原理）</h2><h2 id="7-两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）"><a href="#7-两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）" class="headerlink" title="7.两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）"></a>7.两个闹钟间隔20分钟，较早的音量小时间短（个人推荐潮汐以及iOS就寝的闹钟，比自带温和很多）</h2><h2 id="8-不要赖床，醒得早不想起床会是抑郁症的前兆"><a href="#8-不要赖床，醒得早不想起床会是抑郁症的前兆" class="headerlink" title="8.不要赖床，醒得早不想起床会是抑郁症的前兆"></a>8.不要赖床，醒得早不想起床会是抑郁症的前兆</h2><h2 id="9-起床后沐浴阳光一会有助于提升状态，时自身更加清醒。"><a href="#9-起床后沐浴阳光一会有助于提升状态，时自身更加清醒。" class="headerlink" title="9.起床后沐浴阳光一会有助于提升状态，时自身更加清醒。"></a>9.起床后沐浴阳光一会有助于提升状态，时自身更加清醒。</h2><h2 id="10-吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽"><a href="#10-吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽" class="headerlink" title="10.吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽"></a>10.吃早饭，咀嚼有利于增加记忆力，忌狼吞虎咽</h2><h2 id="11-下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）"><a href="#11-下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）" class="headerlink" title="11.下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）"></a>11.下午和夜晚尽量进行简单的工作（学生的话就睡前背书吧正好是记忆力强的阶段）</h2><h2 id="12-吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品"><a href="#12-吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品" class="headerlink" title="12.吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品"></a>12.吃好晚饭不能不吃，睡前一小时吃完，避免油炸等不易消化的食品</h2><h2 id="13-白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）"><a href="#13-白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）" class="headerlink" title="13.白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）"></a>13.白天小睡如20分钟（不能超30分钟，否则会患某些疾病以及注意力低下）</h2>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>Java学习记录</title>
    <url>/2020/03/02/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E6%9C%89%E4%B8%80%E5%AE%9AC++%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p>作者有着C/C++的基础，在此记录学习Java过程中所了解的Java的一些特性。</p>
<blockquote>
<p>修订：强烈推荐GitHub上的<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/questions/java-learning-path-and-methods.md" target="_blank" rel="noopener">Java 学习路线和方法</a></p>
</blockquote>
<h1 id="数据类型方面"><a href="#数据类型方面" class="headerlink" title="数据类型方面"></a>数据类型方面</h1><ul>
<li>float与double类型在定义时需要在后面加上f/F与d/D</li>
<li>byte/short/char类型在进行运算时都会首先被提升为int型，而后计算。</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>数字字面量中允许包含下划线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Underscores &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d = 341_435_936.445_667;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111;</span><br><span class="line">        System.out.println(Integer.toBinaryString(bin));</span><br><span class="line">        System.out.printf(&quot;%x%n&quot;, bin); // [1]</span><br><span class="line">        long hex = 0x7f_e9_b7_aa;</span><br><span class="line">        System.out.printf(&quot;%x%n&quot;, hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.41435936445667E8</span><br><span class="line">101111101011111010111110101111</span><br><span class="line">2fafafaf</span><br><span class="line">7fe9b7aa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： Java 用 %n    实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 System.out.printf() 或 System.out.format() 时。对于 System.out.println()，我们仍然必须使用 \n；如果你使用 %n，println() 只会输出 %n 而不是换行符。</p>
<ul>
<li>移位运算符<br><br>移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。左移位运算符 <code>&lt;&lt;</code> 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。右移位运算符 <code>&gt;&gt;</code> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（<code>&gt;&gt;&gt;</code>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。这一运算符是 C/C++ 没有的。</li>
<li>Java没有sizeof<br><br>在 C/C++ 中，经常需要用到 sizeof() 方法来获取数据项被分配的字节大小。Java 不需要 sizeof() 方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我们不必考虑这个层次的移植问题 —— Java 本身就是一种“与平台无关”的语言。</li>
</ul>
</blockquote>
<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h2><ul>
<li>static的含义<br><br>static 方法中不会存在 this。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。</li>
<li>垃圾回收器<br><br>Java使用垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。并且由于垃圾回收的存在，使得 Java 没有析构函数。</li>
<li>初始化 <br><br>基本类型变量如果没有赋值会默认为0初始值。字符型为’/u0000’，布尔类型为False，引用为null。</li>
</ul>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>划分为5个部分</p>
<h4 id="1-栈（Stack）：存放方法中的局部变量，方法运行也在栈当中"><a href="#1-栈（Stack）：存放方法中的局部变量，方法运行也在栈当中" class="headerlink" title="1.栈（Stack）：存放方法中的局部变量，方法运行也在栈当中"></a>1.栈（Stack）：存放方法中的局部变量，方法运行也在栈当中</h4><p>局部变量：方法{}中的变量 与 方法的参数<br><br>作用域： 超出作用域，则从栈内存中消失。</p>
<h4 id="2-堆（Heap）：凡是new出来的东西都在其中"><a href="#2-堆（Heap）：凡是new出来的东西都在其中" class="headerlink" title="2.堆（Heap）：凡是new出来的东西都在其中"></a>2.堆（Heap）：凡是new出来的东西都在其中</h4><p>堆内存中的东西都有一个地址值（16进制）<br><br>堆内存中的东西都有默认值，规则如上</p>
<h4 id="3-方法区（Method-Area）：存储-class相关信息，包含方法的信息"><a href="#3-方法区（Method-Area）：存储-class相关信息，包含方法的信息" class="headerlink" title="3.方法区（Method Area）：存储.class相关信息，包含方法的信息"></a>3.方法区（Method Area）：存储.class相关信息，包含方法的信息</h4><h4 id="4-本地方法栈（Native-Method-Stack）：与操作系统相关"><a href="#4-本地方法栈（Native-Method-Stack）：与操作系统相关" class="headerlink" title="4.本地方法栈（Native Method Stack）：与操作系统相关"></a>4.本地方法栈（Native Method Stack）：与操作系统相关</h4><h4 id="5-寄存器（pc-Register）：与CPU相关"><a href="#5-寄存器（pc-Register）：与CPU相关" class="headerlink" title="5.寄存器（pc Register）：与CPU相关"></a>5.寄存器（pc Register）：与CPU相关</h4><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h4 id="1-关于私有类成员变量的设置或者获取的方法"><a href="#1-关于私有类成员变量的设置或者获取的方法" class="headerlink" title="1.关于私有类成员变量的设置或者获取的方法"></a>1.关于私有类成员变量的设置或者获取的方法</h4><p>命名规则为：SetXxx /  GetXxx ，并且Setter不能有返回值，Getter不能有参数。特别的，对于boolen数据类型方法Getter写为IsXxx。</p>
<h4 id="2-Java-标准类"><a href="#2-Java-标准类" class="headerlink" title="2.Java 标准类"></a>2.Java 标准类</h4><p>一个标准类至少有以下四个部分：<br><br>1.所有成员变量都由private修饰<br><br>2.每个成员变量都有对应的Getter/Setter<br><br>3.一个无参数的构造方法<br><br>4.一个全参数的构造方法<br></p>
<blockquote>
<p>这样的类也叫Java bean(Ideal中，在Code菜单栏下Generate可以自动生成对应代码)</p>
</blockquote>
<h4 id="3-静态修饰-static-相关"><a href="#3-静态修饰-static-相关" class="headerlink" title="3.静态修饰 static 相关"></a>3.静态修饰 static 相关</h4><p>1.静态成员变量类的所有对象共享<br><br>2.静态方法属于类，不属于对象，并且不可调用非静态内容。<br><br>3.静态代码块如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    内容</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>当第一次用到本类时，该部分执行唯一的一次，并且比构造方法先执行。一般用于一次性对静态成员变量赋值。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h4><ul>
<li><p>Java中继承使用 extends 关键字，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 子类 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类方法若是想访问重名的父类成员变量，可以使用 super 关键字，方法类似于 this。当子类方法名称与参数都和父类一致时，子类方法将覆盖父类方法，即重写（override）。</p>
<blockquote>
<p>注意： 重写必须满足 子类方法返回值小于等于父类范围 与 子类方法权限大于等于父类（public &gt; protect &gt; default &gt; private）</p>
</blockquote>
</li>
<li><p>子类对象构造时会先调用父类的构造方法(本质是在子类构造方法中编译器将默认插入<code>super()</code> ),可以通过super关键字在子类构造函数中调用父类的重载构造. 另外父类构造调用必须是子类构造方法的第一个语句,不能多次调用，并且不能与this构造方法同时出现.</p>
</li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4><ul>
<li>Java是单继承的，即只能有一个父类</li>
<li>Java可以多级继承，即父类还有父类</li>
<li>Java中父类可以有多个子类</li>
</ul>
<h4 id="3-抽象"><a href="#3-抽象" class="headerlink" title="3.抽象"></a>3.抽象</h4><ul>
<li>方法名前加上abstract并去掉大括号以分号结束，即构造了抽象方法</li>
<li>抽象方法所在类必须是抽象类，即在class之前加上abstract关键字。</li>
<li>抽象类不能直接使用，必须构造子类<strong>覆盖所有抽象方法</strong>，然后创建子类对象进行使用</li>
</ul>
<h3 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h3><p>接口是一种公共的规范标准。是Java语言比较独特的部分。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>关键字为interface。</p>
<ul>
<li>接口中能够包含的有：<br></li>
</ul>
<p>1.常量。以public static final 修饰，近似于【常量】，必须赋值。<em>（推荐命名规则：完全大写）</em><br><br>2.抽象方法。 抽象方法定义固定以public abstract 修饰（也可省略）。<br><br>3.默认方法（Java8以上）。为了解决接口升级问题，允许有方法体，由public default 修饰 <br><br>4.静态方法（Java8以上）。不能通过接口实现类的对象调用，通过接口名称直接调用。<br><br>5.私有方法（Java9以上）<br></p>
<ul>
<li>接口不能直接使用，需要实现类来“实现”。规则类似于继承，extends关键字改为implement。接口的实现类必须覆盖所有抽象方法。一个类可以实现多个接口，同时接口也可以多继承。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>代码中实现多态，即父类引用指向子类对象。又可以称为对象向上转型，即把子类对象当作父类来用。当需要调用子类所特有方法时，对象向下转型（还原），格式为 <code>子类名称 对象名 = （子类名称）父类对象</code>。</p>
<blockquote>
<p>可以使用 instanceof 来判断对象的类别，返回值为布尔型。 </p>
</blockquote>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><ul>
<li>文件类File ，基于File类可以完成查看文件是否存在，文件夹下有那些文件，查看文件大小等操作。</li>
<li>读取与写入文件则需要字节输入输出流 FileInputStream 与 FileOutputStream 。<br>读取文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span><br><span class="line">    File f =new File(&quot;d:/lol.txt&quot;);</span><br><span class="line">    //创建基于文件的输入流</span><br><span class="line">    FileInputStream fis =new FileInputStream(f);</span><br><span class="line">    //创建字节数组，其长度就是文件的长度</span><br><span class="line">    byte[] all =new byte[(int) f.length()];</span><br><span class="line">    //以字节流的形式读取文件所有内容</span><br><span class="line">    fis.read(all);</span><br><span class="line">    for (byte b : all) &#123;</span><br><span class="line">        //打印出来是65 66</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //每次使用完流，都应该进行关闭</span><br><span class="line">    fis.close();</span><br><span class="line">      </span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>写入文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 准备文件lol2.txt其中的内容是空的</span><br><span class="line">    File f = new File(&quot;d:/lol2.txt&quot;);</span><br><span class="line">    // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span><br><span class="line">    byte data[] = &#123; 88, 89 &#125;;</span><br><span class="line"> </span><br><span class="line">    // 创建基于文件的输出流</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(f);</span><br><span class="line">    // 把数据写入到输出流</span><br><span class="line">    fos.write(data);</span><br><span class="line">    // 关闭输出流</span><br><span class="line">    fos.close();</span><br><span class="line">     </span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // TODO Auto-generated catch block</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意流使用完需要关闭，一般.close()即可。除了正常调用函数方式，把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</p>
</blockquote>
<ul>
<li>与之类似的是字符流：FileReader  FileWriter 。区别在于一个是byte 一个是char<br>。另外，<br>使用类似于<code>new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;));</code>可以转换编码</li>
<li>其他数据类型使用数据流DataInputStream与DataOutputStream 类操作。特别的，对象经过序列化后也可以通过ObjectInputStream/ObjectOutputStream来读写。<blockquote>
<p>注：把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口</p>
</blockquote>
</li>
<li>以上的使用都会频繁的读写硬盘，效率较低，为了改善这个问题，我们使用缓存流，读写在缓存区完成。对应的缓存流类是 BufferedReader。</li>
<li>从控制台读写数据通过system.in/system.out 示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        Scanner s = new Scanner(System.in);</span><br><span class="line">         </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String line = s.nextLine();</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="集合与框架"><a href="#集合与框架" class="headerlink" title="集合与框架"></a>集合与框架</h1><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><h4 id="1-ArrayList-集合类"><a href="#1-ArrayList-集合类" class="headerlink" title="1.ArrayList 集合类"></a>1.ArrayList 集合类</h4><p>不同于数组，长度可变。集合中数据类型固定，并且不能是基本数据类型。其实现List接口。<br><br>如果想存储基本数据类型，需要使用该基本数据类型对应的包装类。包装类：将基础数据类型首字母大写，特别的int 对应 Integer char对应 Character<br><br>集合创建格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>：<br>添加 add（） 获取 get（） 删除remove（）返回被删除值  查看大小 size（）<br><br><strong>遍历</strong>：一般有 for循环，iterator迭代器，增强型for循环三种方式。增强型for循环示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (Hero h : heros) &#123;</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-LinkedList-集合类"><a href="#2-LinkedList-集合类" class="headerlink" title="2.LinkedList 集合类"></a>2.LinkedList 集合类</h3><p>与ArrayList一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。LinkedList特别在于，除了实现了List接口外，LinkedList还实现了双向链表结构Deque（可以很方便的在头尾插入删除数据），以及Queue接口(队列)。<br></p>
<blockquote>
<p>Queue是先进先出队列 FIFO，常用方法：<br><br>&#160; &#160;offer 在最后添加元素<br><br>&#160; &#160;poll 取出第一个元素<br><br>&#160; &#160;peek 查看第一个元素<br></p>
</blockquote>
<p> ArrayList和LinkedList的区别:<br><br> ArrayList 插入，删除数据慢<br><br>LinkedList， 插入，删除数据快<br><br>ArrayList是<strong>顺序结构</strong>，所以定位很快，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。<br><br>LinkedList 是<strong>链表结构</strong>，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以定位慢</p>
<h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3.HashMap"></a>3.HashMap</h3><p>HashMap储存数据的方式是—— 键值对 <em>（类似python中的字典）</em> 对于HashMap而言，key是唯一的，不可以重复的。基本使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Hero&gt; heroMap = new HashMap&lt;String,Hero&gt;();</span><br><span class="line">heroMap.put(&quot;gareen&quot;, new Hero(&quot;gareen1&quot;));</span><br></pre></td></tr></table></figure>

<p>HashMap使用类似于字典的存储与查找方式，将键值转换为Hashcode保存，这样在查找数据时速度非常快。<br>与之类似的还有HashSet，Set中的元素，不能重复，并且没有顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">names.add(&quot;gareen&quot;);</span><br><span class="line"> </span><br><span class="line">//第二次插入同样的数据，是插不进去的，容器中只会保留一个</span><br><span class="line">names.add(&quot;gareen&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="4-Collection接口与Collections工具类"><a href="#4-Collection接口与Collections工具类" class="headerlink" title="4.Collection接口与Collections工具类"></a>4.Collection接口与Collections工具类</h3><p>Collection是 Set List Queue（先进先出队列）和 Deque（双向链表）的接口。List等都继承了Collection<br><br>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类。用来实现对集合数据的一些操作。常用方法如下：<br><br>reverse     反转<br><br>shuffle     混淆<br><br>sort    排序<br><br>swap    交换<br><br>rotate  滚动<br><br>synchronizedList    线程安全化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    numbers.add(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;集合中的数据:&quot;);</span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Collections.reverse(numbers);</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;翻转后集合中的数据:&quot;);</span><br><span class="line">System.out.println(numbers);</span><br></pre></td></tr></table></figure>

<p>特别的在对某类的对象进行排序时，需要通过Comparator重写排序的规则，或者在该类中实现Comparable接口。</p>
<h3 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h3><p>泛型是 JDK1.5 的一个新特性，其实就是一个『语法糖』，本质上就是编译器为了提供更好的可读性而提供的一种小「手段」，对于 JVM 运行时的性能是没有任何影响的。<br><br>泛型的用法是在容器后面添加<type>，Type可以是类，抽象类，接口。这样容器中就只能存放这种type（或者其子类）的内容。基本写法如下：<br><br><code>ArrayList&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;()</code><br></type></p>
<ul>
<li><p>设计一个类的时候，在类的声明上，加上一个<t>，表示该类支持泛型。</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class MyStack&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;T&gt; values = new LinkedList&lt;T&gt;();</span><br><span class="line">       </span><br><span class="line">    public void push(T t) &#123;</span><br><span class="line">        values.addLast(t);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T pull() &#123;</span><br><span class="line">        return values.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public T peek() &#123;</span><br><span class="line">        return values.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //在声明这个Stack的时候，使用泛型&lt;Hero&gt;就表示该Stack只能放Hero</span><br><span class="line">        MyStack&lt;Hero&gt; heroStack = new MyStack&lt;&gt;();</span><br><span class="line">        heroStack.push(new Hero());</span><br><span class="line">        //不能放Item</span><br><span class="line">        heroStack.push(new Item());</span><br><span class="line">         </span><br><span class="line">        //在声明这个Stack的时候，使用泛型&lt;Item&gt;就表示该Stack只能放Item</span><br><span class="line">        MyStack&lt;Item&gt; itemStack = new MyStack&lt;&gt;();</span><br><span class="line">        itemStack.push(new Item());</span><br><span class="line">        //不能放Hero</span><br><span class="line">        itemStack.push(new Hero());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型通配符<br><br>分为三种：无界泛型通配符<code>?</code>,子类限定泛型通配符<code>? extends</code>,父类限定泛型通配符<code>? super</code>。<br>一般是为了解决复用性问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method(ArrayList&lt;?&gt; arr) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-Lambda表达式"><a href="#6-Lambda表达式" class="headerlink" title="6.Lambda表达式"></a>6.Lambda表达式</h3><p>一种简写语法，类似于简化的匿名类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            heros.add(new Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;初始化后的集合：&quot;);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">           </span><br><span class="line">        HeroChecker c = new HeroChecker() &#123;</span><br><span class="line">            public boolean test(Hero h) &#123;</span><br><span class="line">                return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        System.out.println(&quot;使用匿名类过滤&quot;);</span><br><span class="line">        filter(heros, c);</span><br><span class="line">        System.out.println(&quot;使用Lambda表达式&quot;);</span><br><span class="line">        filter(heros, h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</span><br><span class="line">        System.out.println(&quot;在Lambda表达式中使用静态方法&quot;);</span><br><span class="line">        filter(heros, h -&gt; TestLambda.testHero(h) );</span><br><span class="line">        System.out.println(&quot;直接引用静态方法&quot;);</span><br><span class="line">        filter(heros, TestLambda::testHero);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    public static boolean testHero(Hero h) &#123;</span><br><span class="line">        return h.hp&gt;100 &amp;&amp; h.damage&lt;50;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    private static void filter(List&lt;Hero&gt; heros, HeroChecker checker) &#123;</span><br><span class="line">        for (Hero hero : heros) &#123;</span><br><span class="line">            if (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的，还有lamda聚合操作，暂不细究。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><strong>创建多线程</strong>一般有三种方式：<br></li>
</ul>
<p>1.继承Thread类<br><br>2.实现Runnable接口<br><br>3.匿名类的方式<br><br>重写run方法后，调用start（）开始线程。<br></p>
<ul>
<li><p><strong>常见的线程方法</strong>：<br><br>sleep  当前线程暂停<br><br>join   加入到当前线程中    </p>
<br>
setPriority 线程优先级<br>
yield  临时暂停<br>
setDaemon 守护线程<br></li>
<li><p><strong>线程同步</strong><br>为了防止多个线程操作同一对象时造成混乱，提出同步。基本功能就是当某个线程操作某对象时，独占这个对象，其他线程不能更改。同步使用synchronized关键字或者lock对象。<br>1.synchronized 块，如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object someObject =new Object();</span><br><span class="line">synchronized (someObject)&#123;</span><br><span class="line">  //此处的代码只有占有了someObject后才可以执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  2 .在类的方法前，加上修饰符synchronized。这样外部线程访问该方法时即为独占状态。另外，如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类。一些HashSet,LinkedList,HashMap等等非线程安全的类可以转化为线程安全类。<br><br>  3 . 使用lock对象。与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。<br><br>  另外，lock中还有trylock方法，会指定时间内尝试对对象进行独占，使用这个方法可以比较有效的避免死锁的情况产生。</p>
</li>
<li><p><strong>线程交互</strong>  使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法<br></p>
<blockquote>
<p>wait()–<em>让占用了这个同步对象的线程，临时释放当前的占用，并且等待.</em> <br> notify()– <em>唤醒在此对象监视器上等待的单个线程</em><br><br>  notifyAll()–<em>唤醒在此对象监视器上等待的所有线程</em><br></p>
</blockquote>
<p>  Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：await, signal,signalAll 方法。</p>
</li>
<li><p><strong>线程池</strong><br>基本想法在于循环使用线程池中的线程。线程池类ThreadPoolExecutor。</p>
</li>
</ul>
<h1 id="JDBC–java与数据库的连接"><a href="#JDBC–java与数据库的连接" class="headerlink" title="JDBC–java与数据库的连接"></a>JDBC–java与数据库的连接</h1><p>这里以mysql为例</p>
<h3 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h3><ul>
<li><p>为项目导入mysql-jdbc的jar包，使用JDBC连接MySQL数据库的驱动为<a href="https://dev.mysql.com/downloads/windows/installer/8.0.html" target="_blank" rel="noopener">Connentor/J</a></p>
</li>
<li><p>解压并在ideal或者其他IDE中导入mysql-connector-java-8.0.13.jar包。</p>
</li>
<li><p>通过<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br>初始化驱动类com.mysql.jdbc.Driver</p>
</li>
<li><p>建立与数据库的连接。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">// 建立与数据库的Connection连接</span><br><span class="line">// 这里需要提供：</span><br><span class="line">// 数据库所处于的ip:127.0.0.1 (本机)</span><br><span class="line">// 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">// 数据库名称 how2java</span><br><span class="line">// 编码方式 UTF-8</span><br><span class="line">// 账号 root</span><br><span class="line">// 密码 admin</span><br><span class="line"></span><br><span class="line">Connection c = DriverManager</span><br><span class="line">    .getConnection(</span><br><span class="line">            &quot;jdbc:mysql://127.0.0.1:3306/how2java?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;,</span><br><span class="line">            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数据库进行操作<br>创建Statement是用于执行SQL语句</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Statement s = c.createStatement();</span><br><span class="line">// 准备sql语句</span><br><span class="line">String sql = &quot;insert into hero values(null,&quot;+&quot;&apos;提莫&apos;&quot;+&quot;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;;</span><br><span class="line">s.execute(sql);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭连接<br><br>有两种方式，调用close方法（注意先关Statement，后关Connection） 或者使用try-with-resource的方式自动关闭连接</p>
<h3 id="特别的地方"><a href="#特别的地方" class="headerlink" title="特别的地方"></a>特别的地方</h3></li>
<li><p>JDBC中使用预编译STATEMENT—PreparedStatement<br><br>和 Statement一样，PreparedStatement也是用来执行sql语句的<br>与创建Statement不同的是，需要根据sql语句创建PreparedStatement<br>除此之外，还能够通过设置参数，指定相应的值，而不是Statement那样使用字符串拼接。 这样做的好处在于可读性好，性能更好，预防sql注入式攻击。<br></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    String sql = &quot;insert into hero values(null,?,?,?)&quot;;</span><br><span class="line">    try (Connection c = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;,&quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">        // 根据sql语句创建PreparedStatement</span><br><span class="line">        PreparedStatement ps = c.prepareStatement(sql);</span><br><span class="line">    ) &#123;</span><br><span class="line">         </span><br><span class="line">        // 设置参数</span><br><span class="line">        ps.setString(1, &quot;提莫&quot;);</span><br><span class="line">        ps.setFloat(2, 313.0f);</span><br><span class="line">        ps.setInt(3, 50);</span><br><span class="line">        // 执行</span><br><span class="line">        ps.execute();</span><br><span class="line">  </span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正常操作会将数据库相关的操作都封装在一个类/接口里面，叫做数据访问对象。</p>
</li>
<li><p>与线程池类似的，数据库也有一个数据库连接池。<br><br>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面借用，而不是自己重新创建.<br>使用完毕后，又把这个连接归还给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被借用光了，那么其他线程就会临时等待，直到有连接被归还回来，再继续使用。<br>整个过程，这些连接都不会被关闭，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
<h1 id="常用类与函数"><a href="#常用类与函数" class="headerlink" title="常用类与函数"></a>常用类与函数</h1><h4 id="2-字符串类"><a href="#2-字符串类" class="headerlink" title="2.字符串类"></a>2.字符串类</h4><p>java程序中所有出现的双引号字符串都是String类的对象<br><br>字符串创建后不可更改。<br><br>字符串除了可以直接创建外，还可以通过字符数组或者字节数组创建。注意，直接创建的字符串放在字符串常量池中，相同字符串在池中只创建一次。<br><br>与之类似的StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br></p>
</li>
</ul>
<p><strong>常用方法</strong>：<br></p>
<ul>
<li><p>比较/忽略大小写比较： equals（） / equalsIgnoreCase()</p>
<blockquote>
<p>一般将常量字符串写在前面，例如：”abc”.equals(str)</p>
</blockquote>
</li>
<li><p>获取字符串长度： int length（）<br></p>
</li>
<li><p>拼接并返回新字符串： String concat（String str）<br></p>
</li>
<li><p>获取索引位置字符： char charAt（int index）<br></p>
</li>
<li><p>查找参数字符串在本字符串中首次出现的位置： int indexOf（String str）<br></p>
</li>
<li><p>字符串截取 参数位置到结尾/【begin，end）： String substring（int index/int begin，int end）<br></p>
</li>
<li><p>拆分成字符数组： char[] toCharArray()<br></p>
</li>
<li><p>拆分成字节数组： byte[] getBytes()<br></p>
</li>
<li><p>替换 ： String replace（CharSequence oldString， CharSequence newstring）<br></p>
</li>
<li><p>分割字符串： String[] split(String regex)<br></p>
</li>
</ul>
<h4 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h4><p>这是个与数组相关的工具类，里面包含许多有用的静态方法，例如：</p>
<ul>
<li>Stirng toString（数组）：数组转字符串（默认格式，即类似于[元素1，元素2，元素3，…]）</li>
<li>void sort（数组）：数组排序，默认升序<h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类<br></h4>数学相关的工具类</li>
</ul>
<p><strong>常用方法</strong>有：<br></p>
<ol>
<li>double abs(double num)  获取绝对值</li>
<li>double ceil(double num) 向上取整</li>
<li>double floor(double num) 向下取整</li>
<li>long round(double num)  四舍五入</li>
<li>Math.PI 近似圆周率<h4 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h4>util.Date类：时间原点，其对应的日期是1970年1月1日 8点0分0秒，以此为基准，每过一毫秒，就+1。getTime() 得到一个long型的整数。直接打印对象，会看到 “Tue Jan 05 09:51:48 CST 2016” 这样的格式。想要转化为好看的格式就需要下面的类。</li>
</ol>
<p>SimpleDateFormat 日期格式化类：构造方法类似<code>SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot; )</code>。之后使用.format(Data)方法返回对应格式的字符串。也可以通过.parse(str)将字符串转为日期类。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常分类： 可查异常，运行时异常和错误3种。异常分Error和Exception<br>Exception里又分运行时异常和可查异常。Exception和Error的父类是Throwable，<br>所以在捕捉的时候，也可以使用Throwable进行捕捉。java也允许自定义异常。<br><br>java通过try catch 处理异常，也可以加入finally代码段（无论是否异常，都将执行）或者通过throw/throws关键字抛出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void method1() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void method2() throws FileNotFoundException &#123;</span><br><span class="line"> </span><br><span class="line">    File f = new File(&quot;d:/LOL.exe&quot;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;试图打开 d:/LOL.exe&quot;);</span><br><span class="line">    new FileInputStream(f);</span><br><span class="line">    System.out.println(&quot;成功打开&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ideal相关"><a href="#Ideal相关" class="headerlink" title="Ideal相关"></a>Ideal相关</h1><h4 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h4><p>Alt+Enter  修正代码<br><br>ctrl+Y    删除光标所在行<br><br>ctrl+D    复制所在行并插入光标位置下面<br><br>ctrl+Alt+L  格式化代码<br><br>ctrl+/     注释当前行<br><br>ctrl+shift+/  注释多行<br><br>Alt+insert    自动生成代码<br><br>Alt+Shift+上下箭头 移动当前行<br></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网站资源整理</title>
    <url>/2020/02/25/%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>记录下所搜集的有价值的网站</p>
<h1 id="1-信息获取"><a href="#1-信息获取" class="headerlink" title="1.信息获取"></a>1.信息获取</h1><ul>
<li><a href="https://www.kaolamedia.com/" target="_blank" rel="noopener">新媒体导航</a><br>门户式网站，主要面向新媒体从业者。内容很多，非从业者也值得一看，集合了许多工具网站，数据网站，流量报价网站的入口。</li>
<li><a href="https://tophub.today/" target="_blank" rel="noopener">全网热点</a><br>将大部分知名的平台的热点榜单集合到一个网站上，总览全网热点。</li>
</ul>
<h1 id="2-日常工具"><a href="#2-日常工具" class="headerlink" title="2.日常工具"></a>2.日常工具</h1><ul>
<li><a href="https://slidesgo.com/" target="_blank" rel="noopener">slidesgo</a><br>一个PPT模板网站，风格简洁且不失时尚感，当然重点在于免费，免费，免费！</li>
<li><a href="http://www.eshow365.com/" target="_blank" rel="noopener">展会</a><br>提供全国的展会信息，了解到感兴趣的展会后可去其官网领门票，一般都是免费发放。</li>
<li><a href="http://bg-patterns.com/" target="_blank" rel="noopener">背景素材</a><br>免费的背景素材库，多种格式可选。</li>
<li><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨</a><br>能将背景声与人声分离，效果不错，每日有限定的免费次数。</li>
<li><a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">数据可视化</a><br>非常专业且实用的数据可视化制作网站，功能强大。</li>
<li><a href="https://www.msdmanuals.com/zh#%20mission" target="_blank" rel="noopener">默沙东诊疗手册</a><br>全面且专业的医疗手册，既有专业人士版本也有通俗的大众版，能比较有效的分析可能病症，比百度靠谱多个梯度，值得每个人收藏。</li>
<li><a href="https://www.materialtools.com/" target="_blank" rel="noopener">临时验证码</a><br>对于一些只想临时使用，但是需要注册验证的网站，填写这个网站里的电话号码，用它帮你完成验证，避免被电话骚扰。</li>
<li><a href="https://temp-mail.org/zh/" target="_blank" rel="noopener">临时邮箱</a><br>与临时验证码类似，可以用该网站上的邮箱完成注册验证。</li>
<li><a href="https://www.weiciyun.com/" target="_blank" rel="noopener">词云生成</a><br>较为简单实用的词云在线生成网站。</li>
</ul>
<h1 id="3-趣味类"><a href="#3-趣味类" class="headerlink" title="3.趣味类"></a>3.趣味类</h1><ul>
<li><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">大像素</a><br>一个神奇的网站，所拍摄的照片像素量极大，这意味每一张都存有大量的信息，你可以放大放大再放大体会这种神奇的感觉。</li>
<li><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史</a><br>再这个网站可以了解全球的历史大事脉络，还有许多神奇的功能。</li>
<li><a href="https://learningmusic.ableton.com" target="_blank" rel="noopener">音乐入门</a><br>可视化的教授做音乐的一些基础知识理论的网站。</li>
<li><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI捏人</a><br>非常有趣的网站，可以将不同风格的人物混合得到新的人物概念。通过尝试与调整可以获得独一无二的人物图片。</li>
<li><a href="https://neave.com/" target="_blank" rel="noopener">小集合</a><br>一个外网大佬的网站集合，包括实时地球卫星图，星象图等，既有趣味又有价值。</li>
<li><a href="http://www.shushubuyue.net/#" target="_blank" rel="noopener">匿名聊天网</a><br>网页版匿名的聊天室，挺有意思，还带一点温馨。</li>
</ul>
<h1 id="4-艺术"><a href="#4-艺术" class="headerlink" title="4.艺术"></a>4.艺术</h1><ul>
<li><a href="https://www.ianfisherart.com/" target="_blank" rel="noopener">云</a><br>一个专注于画云的艺术家的作品站，风格独著。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>网站资源</tag>
      </tags>
  </entry>
  <entry>
    <title>window下提升流畅感的小软件</title>
    <url>/2020/01/10/Window%E4%B8%8B%E6%8F%90%E5%8D%87%E6%B5%81%E7%95%85%E6%84%9F%E7%9A%84%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>记录一些好用的window下软件</p>
<h2 id="1-像浏览器一样打开你的文件夹-Clover"><a href="#1-像浏览器一样打开你的文件夹-Clover" class="headerlink" title="1.像浏览器一样打开你的文件夹-Clover"></a>1.像浏览器一样打开你的文件夹-Clover</h2><p>Clover，在Windows原生资源管理器的基础上加上类似Chrome的标签。Clover 把 Chrome 标签页有的样式、功能、右键菜单、快捷键全部移植，如果你常用Chrome浏览器，你应该能瞬间上手。</p>
<ul>
<li>你可以用Ctrl+T新开页面，Ctrl+W关闭页面，Ctrl+Tab切换页面，这和你使用Chrome浏览器是完全一样的！</li>
<li>Ctrl+D，（或者右键或者直接将文件夹拖入书签栏）可以添加当前路径到书签栏，常用的文件夹再也不用挨着打开文件夹找了！</li>
<li>鼠标滚轮点选文件夹时新建标签页</li>
<li>双击文件夹空白处跳到上层目录</li>
<li>双击标签标题时关闭当前标签页</li>
<li>在标签栏上使用鼠标滚轮来切换标签页<br>WIN10 建议用<a href="http://t.cn/Ai8YHRnK" target="_blank" rel="noopener">Clover3.5.2版</a>，WIN7 / XP 建议使用<a href="http://t.cn/Ai8YH0Cs" target="_blank" rel="noopener">Clover3.0.406版</a></li>
</ul>
<h2 id="2-透明任务栏–TranslucentTB"><a href="#2-透明任务栏–TranslucentTB" class="headerlink" title="2.透明任务栏–TranslucentTB"></a>2.透明任务栏–TranslucentTB</h2><p>注意，这款软件只支持Win10，在Microsoft store中可以免费获取。</p>
<h2 id="3-超快的文件搜索工具–everything"><a href="#3-超快的文件搜索工具–everything" class="headerlink" title="3.超快的文件搜索工具–everything"></a>3.超快的文件搜索工具–everything</h2><p>它还是一款完全免费的软件，界面简洁高效，软件大小只有不到2M，但功能却非常丰富。官网<a href="https://www.voidtools.com/zh-cn/downloads/" target="_blank" rel="noopener">直接下载</a>。</p>
<h2 id="4-系统清理与优化–系统优化加速工具"><a href="#4-系统清理与优化–系统优化加速工具" class="headerlink" title="4.系统清理与优化–系统优化加速工具"></a>4.系统清理与优化–系统优化加速工具</h2><p>由联想的高级工程师开发，无需解压，无需安装，下载即用。这个软件的清理功能一般，主要用来优化各种系统设置、系统服务项，所以一般只运行一次就行了。<a href="https://url.cn/5NxOByn" target="_blank" rel="noopener">下载地址</a></p>
<h2 id="5-革命性的搜索和应用启动软件–Listary"><a href="#5-革命性的搜索和应用启动软件–Listary" class="headerlink" title="5.革命性的搜索和应用启动软件–Listary"></a>5.革命性的搜索和应用启动软件–Listary</h2><p>与Everything类似，但是其功能更加适用于LabVIEW程序开发人员，或者常常与文件保存打开打交道的工作人员。无论何时何地，都可以连按两次 Ctrl 键来启动 Listary ，搜索你的应用和文件。非常方便，<a href="http://www.listary.com/download" target="_blank" rel="noopener">官网</a>即可下载。</p>
<h2 id="6-一些其他常用操作"><a href="#6-一些其他常用操作" class="headerlink" title="6.一些其他常用操作"></a>6.一些其他常用操作</h2><ul>
<li>常用快捷键：WIN+E打开 我的电脑</li>
<li>隐藏系统图标：桌面右键——「个性化」——「主题」——「桌面图标设置」。在隐藏回收站图标之前，先右键回收站图标——创建快捷方式——然后把快捷方式扔到你的快速启动目录中去</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>软件工具</tag>
      </tags>
  </entry>
  <entry>
    <title>随想</title>
    <url>/2020/01/08/%E9%9A%8F%E6%83%B3/</url>
    <content><![CDATA[<p>关于经济形势<br>新的市场结构已经形成，旧的价值在衰退，不稳定性在增加并造成影响。</p>
<a id="more"></a>
<p>具体来说，中产阶层已经成为了市场中的消费主力，这对应着近来文娱的发展获利，中高端食品业的成功等等，其影响尚未达到峰顶，趋势仍在行进。旧有的许多产业已经达到高位，房地产，IT已经是维稳甚至下滑的阶段。生产过剩，债务泡沫，以及随之而来的劳动力过剩所造成的危机正在酝酿，国际上几乎所有国家都在沼泽上行走，等待着谁先沉没然后他者踩着它的尸体再多走一段。</p>
<p>就国内而言，可能的希望在于三个大区域（珠三角，长三角，北京区域）一体化的开发，新的技术革命的到来，新乡村新农业的开发（温铁军教授所言），最后国际形势的转变（其他国家倒下了，让出了地盘）。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>云服务器搭建私有云盘</title>
    <url>/2020/01/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98/</url>
    <content><![CDATA[<p>租了个云服务器，想着把它利用起来。先用它搭建个私有云盘吧。<br> <a id="more"></a> </p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>一个云服务器，如果是学生的话推荐阿里云学生服务器<a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云学生服务器</a>，9.5元一个月。<br>有两种，<a href="https://yq.aliyun.com/articles/700446" target="_blank" rel="noopener">区别参见</a>。<br>我是使用预装的centos系统。</p>
<h2 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2.搭建环境"></a>2.搭建环境</h2><p>在云服务器中搭建LAMP环境<a href="https://www.jianshu.com/p/fabe5842c0e1" target="_blank" rel="noopener">（Linux）</a>或者WNMP环境（windows）<br>预装包 </p>
<p><code>sudo yum install php-mysql php-json php-xml php-mbstring php-zip php-gd curl php-curl php-pdo</code></p>
<p>之后的操作都要在root权限下运行</p>
<h2 id="3-安装软件"><a href="#3-安装软件" class="headerlink" title="3.安装软件"></a>3.安装软件</h2><ul>
<li>获取压缩包。<pre><code>wget https://download.owncloud.org/community/owncloud-10.0.4.tar.bz2</code></pre></li>
</ul>
<ul>
<li>解压<pre><code>tar -xvf owncloud-10.0.4.tar.bz2</code></pre></li>
<li>将之移动到 /var/www/html<pre><code>mv owncloud/* /var/www/html </code></pre></li>
</ul>
<h2 id="4-修改配置Apache文件"><a href="#4-修改配置Apache文件" class="headerlink" title="4.修改配置Apache文件"></a>4.修改配置Apache文件</h2><ul>
<li><p>进入conf文件内        </p>
<pre><code>vim /etc/httpd/conf/httpd.conf</code></pre><p>修改AllowOverride none 为 AllowOverride All</p>
</li>
<li><p>更改权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R apache:apache /var/www/html/</span><br><span class="line">$ sudo chmod 777 /var/www/html/config/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Apache 服务器</p>
<pre><code>systemctl restart httpd</code></pre></li>
</ul>
<h2 id="5-在-MariaDB-上创建一个数据库，保存来自-OwnCloud-的数据"><a href="#5-在-MariaDB-上创建一个数据库，保存来自-OwnCloud-的数据" class="headerlink" title="5.在 MariaDB 上创建一个数据库，保存来自 OwnCloud 的数据"></a>5.在 MariaDB 上创建一个数据库，保存来自 OwnCloud 的数据</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">MariaDB [(none)] &gt; create database owncloud;</span><br><span class="line">MariaDB [(none)] &gt; GRANT ALL ON owncloud.* TO ocuser@localhost IDENTIFIED BY &apos;owncloud&apos;;</span><br><span class="line">MariaDB [(none)] &gt; flush privileges;</span><br><span class="line">MariaDB [(none)] &gt; exit</span><br></pre></td></tr></table></figure>

<h2 id="6-检验"><a href="#6-检验" class="headerlink" title="6.检验"></a>6.检验</h2><ul>
<li><p>服务器配置部分完成后，现在我们可以在网页浏览器上访问 OwnCloud。打开浏览器，输入您的服务器 IP 地址，之后按照步骤认证即可。类似下图。</p>
<p>  <img src="/2020/01/08/云服务器搭建私有云盘/0.png" alt></p>
</li>
<li><p>可能的问题：php版本过低请参照<a href="https://towait.com/blog/how-to-upgrade-php-version-54-to-56-on-cento7/" target="_blank" rel="noopener">https://towait.com/blog/how-to-upgrade-php-version-54-to-56-on-cento7/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>win10系统设置任务计划（以自动关机为例）</title>
    <url>/2020/01/08/win10%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%EF%BC%88%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%85%B3%E6%9C%BA%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>如何通过任务计划程序设置自动关机或者类似自动执行<br>可以设置单次任务，也可以设置长期执行的任务，适合设置有规律的关机计划。</p>
<a id="more"></a>
<h2 id="1-打开程序"><a href="#1-打开程序" class="headerlink" title="1 打开程序"></a>1 打开程序</h2><p>控制面板——管理工具——任务计划程序(也可以在开始菜单左下角的搜索程序和文件中输入“任务计划程序”来找到)，创建一个基本任务。</p>
<h2 id="2-按要求设置任务"><a href="#2-按要求设置任务" class="headerlink" title="2 按要求设置任务"></a>2 按要求设置任务</h2><p>输入名称，描述可以不写，进入下一步。<br>选择任务的执行频率，继续下一步。<br>在操作中，选择启动程序。<br>在程序或脚本一栏填入shutdown即可，同样参数可选择性填写。</p>
<h2 id="3-此时即可在列表中看见该任务"><a href="#3-此时即可在列表中看见该任务" class="headerlink" title="3  此时即可在列表中看见该任务"></a>3  此时即可在列表中看见该任务</h2>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>python 充分利用CPU</title>
    <url>/2020/01/07/python-%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8CPU/</url>
    <content><![CDATA[<p>当利用python处理大规模数据或者运行一些耗时较长的程序时，往往会发现程序运行时CPU并没有跑满，哪怕开了多线程后CPU利用率仍然不高。这是因为在默认情况下，Python 程序是单个进程，使用单 CPU 核心执行，这意味着多核处理器只使用了一个核。「一核有难九核围观」意味着超过 50% 的算力都会被浪费。这篇文章将介绍如何解决这种情况。</p>
<a id="more"></a>
<h2 id="多线程无法增加cpu使用率的原因"><a href="#多线程无法增加cpu使用率的原因" class="headerlink" title="多线程无法增加cpu使用率的原因"></a>多线程无法增加cpu使用率的原因</h2><p>GIL 的全程为 Global Interpreter Lock ，意即全局解释器锁。在 Python 语言的主流实现 CPython 中，GIL 是一个货真价实的全局线程锁，在解释器解释执行任何 Python 代码时，都需要先获得这把锁才行，在遇到 I/O 操作时会释放这把锁。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）。所以虽然 CPython 的线程库直接封装操作系统的原生线程，但 CPython 进程做为一个整体，同一时间只会有一个获得了 GIL 的线程在跑，其它的线程都处于等待状态等着 GIL 的释放。这就意味着哪怕开了多线程CPU使用率仍然不会很高。</p>
<h2 id="如何充分使用多核跑程序"><a href="#如何充分使用多核跑程序" class="headerlink" title="如何充分使用多核跑程序"></a>如何充分使用多核跑程序</h2><p>有三个办法</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p> multiprocessing 是多进程标准库，让多进程的 python 程序编写简化到类似多线程的程度，通过多进程的方式使用多个CPU核心。</p>
<h3 id="C-语言扩展机制"><a href="#C-语言扩展机制" class="headerlink" title="C 语言扩展机制"></a>C 语言扩展机制</h3><p>如果不想用多进程这样重量级的解决方案，可以改用 C/C++。当然，你也不用做的这么绝，只需要把关键部分用 C/C++ 写成 Python 扩展，其它部分还是用 Python 来写，让 Python 的归 Python，C 的归 C。一般计算密集性的程序都会用 C 代码编写并通过扩展的方式集成到 Python 脚本里（如 NumPy 模块）。这样在扩展里就完全可以用 C 创建原生线程，就可以充分利用 CPU 的计算资源了。</p>
<h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><p>不过，写 Python 扩展总是让人觉得很复杂。好在 Python 还有另一种与 C 模块进行互通的机制 : ctypes。ctypes 与 Python 扩展不同，它可以让 Python 直接调用任意的 C 动态库的导出函数。你所要做的只是用 ctypes 写些 python 代码即可。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>小白机器学习教程路线</title>
    <url>/2019/09/11/%E5%B0%8F%E7%99%BD%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="一-基础性知识可参照"><a href="#一-基础性知识可参照" class="headerlink" title="一 基础性知识可参照"></a>一 基础性知识可参照</h2><p><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers" target="_blank" rel="noopener">https://github.com/ZuzooVn/machine-learning-for-software-engineers</a>  自上而下的学习路径：软件工程师的机器学习/Top-down learning path: Machine Learning for Software Engineers<br><a href="https://github.com/imhuay/Algorithm_Interview_Notes-Chinese/tree/master/A-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener">https://github.com/imhuay/Algorithm_Interview_Notes-Chinese/tree/master/A-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0</a> 机器学习笔记/marchine learning note chinese</p>
<h2 id="二-kaggle-一个数据建模和数据分析竞赛平台"><a href="#二-kaggle-一个数据建模和数据分析竞赛平台" class="headerlink" title="二 kaggle (一个数据建模和数据分析竞赛平台)"></a>二 kaggle (一个数据建模和数据分析竞赛平台)</h2><p><a href="https://www.kaggle.com/learn/intro-to-machine-learning" target="_blank" rel="noopener">https://www.kaggle.com/learn/intro-to-machine-learning</a>  从kaggle网站中的教程中学习入门知识并实践<br>（这是一个很好的实践性教程，它可以帮助你了解一些核心的机器学习想法并帮助你建立一个机器学习模型，同时它的每一个章节都有可以在线编程的练习。最后，它导向一个很有趣的房价预测相关的比赛，这是开始kaggle的第一步。另外，如果想要在房价预测比赛中得到一个更好的结果，可以参照我的kernel（可以帮助你进入top4%）：<a href="https://www.kaggle.com/smith890/exercise-machine-learning-competitions）" target="_blank" rel="noopener">https://www.kaggle.com/smith890/exercise-machine-learning-competitions）</a><br><a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a>  泰坦尼克号：从灾难中学习机器/Titanic: Machine Learning from Disaster   </p>
<p>##待续</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个自己的博客（hexo+github）</title>
    <url>/2019/09/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-序"><a href="#1-序" class="headerlink" title="1.序"></a>1.序</h2><p>第一篇博客就从怎么搭建的这个博客开始吧。</p>
<h2 id="2-环境配置与准备"><a href="#2-环境配置与准备" class="headerlink" title="2.环境配置与准备"></a>2.环境配置与准备</h2><p>所需要的：</p>
<ul>
<li>安装node.js（<a href="http://https://nodejs.org/en/" title="官网" target="_blank" rel="noopener">官网</a>下载安装即可）</li>
<li>安装git以及一个GitHub账号（如果不清楚请参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="廖雪峰git教程" target="_blank" rel="noopener">廖雪峰git教程</a>）</li>
<li>安装hexo（在已完成安装node.js的情况下，打开cmd 运行npm install -g hexo）</li>
</ul>
<h2 id="3-本地创建博客文件"><a href="#3-本地创建博客文件" class="headerlink" title="3.本地创建博客文件"></a>3.本地创建博客文件</h2><ul>
<li>新建一个存储博客文件的文件夹，例如MyBlog。</li>
<li>进入到这个文件夹内，运行git。在git bash内输入并运行 hexo init（生成博客模板）。生成完后，运行 npm install。</li>
<li>之后你的文件夹内就会生成标准的博客文件模板，文件结构如下：<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>其中：_config.yml： 其中我们以后的大部分操作都会在_config.yml中进行，这个文件是我们的站点的配置文件<br>　　　　scaffolds： 模板文件，规定了我们创建一篇文章的时候最开始的样子，<br>　　　　source： 可以暂时的理解成我们文章的存放处<br>　　　　themes： 主题文件存放处。</li>
<li>之后运行 hexo server 部署到本地，就可以访问本地<a href="http://localhost:4000/" title="localhost：4000" target="_blank" rel="noopener">localhost：4000</a>看见自己的博客</li>
</ul>
<h2 id="4-github中创建用于存放博客的仓库"><a href="#4-github中创建用于存放博客的仓库" class="headerlink" title="4.github中创建用于存放博客的仓库"></a>4.github中创建用于存放博客的仓库</h2><p>　　进入github新建repo，这里要注意repository的名字一定要满足UserName.github.io(这里的UserName是你GitHub账号的名字)。这样最后才能将这个仓库当作个人主页展示。</p>
<h2 id="5-关联本地博客文件夹和GitHub"><a href="#5-关联本地博客文件夹和GitHub" class="headerlink" title="5.关联本地博客文件夹和GitHub"></a>5.关联本地博客文件夹和GitHub</h2><ul>
<li>修改本地博客文件夹下_config.yml，找到最后的deploy部分。修改成：<pre><code>deploy:
    type: git
    repository: https://github.com/UserName/UserNamegithub.io.git
    branch: master</code></pre>其中：<br>　　type值对应的是你所部署的的服务器类型，我们这里填写git就可以。<br>　　repo是你的仓库地址，也就是仓库克隆的地址<br>　　branch不写默认是master，通常我们写成master就可以。<br>特别注意，冒号后需要空一格，例如type： git<br>完成上面的配置后，分别运行：<br>　　hexo clean       清理缓存<br>　　hexo generate 进行渲染 简写 hexo g<br>　　hexo deploy    简写为 hexo d来部署到git服务器<br>执行完后就可以打开浏览器地址，输入http://你github名字.github.io 看到效果了</li>
</ul>
<h2 id="6-开始写文章"><a href="#6-开始写文章" class="headerlink" title="6.开始写文章"></a>6.开始写文章</h2><ul>
<li>原生方式新建文章<br>Hexo的项目结构是在网站根目录的<code>source/_posts</code> 目录下存放你的博客文档，以.md文档格式存储，默认已存在一个hello-world.md文章<br>使用命令<code>hexo new &lt;title&gt;</code>创建文章，支持Markdown语法，也支持一些增强功能标签代码段，用于插入视频图片等。图片可以统一放在<code>source/images</code>目录中，并以<code>![](/images/image.jpg)</code>方式引用或者在<code>_config.yml</code> 打开 post_asset_folder 功能，将当前文章所用的图片放置到source目录下的文章同名资源目录下，以 <code>![](image.jpg)</code> 方式引用</li>
</ul>
<p>另外一些文章中提到建议使用第三方的专业图床来存放这些静态图片素材</p>
<ul>
<li>使用 Hexo Admin 插件<br>Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）<br><code>npm install --save hexo-admin</code> 安装<br><code>hexo server -d</code>  使用<br><code>open http://localhost:4000/admin</code>  </li>
</ul>
<h2 id="7-进阶"><a href="#7-进阶" class="headerlink" title="7.进阶"></a>7.进阶</h2><p>还想要进一步个性化或者增加其他小功能的朋友，推荐参考：</p>
<p><a href="http://yearito.cn/posts/hexo-advanced-settings.html" target="_blank" rel="noopener">Hexo 搭建个人博客系列：进阶设置篇</a></p>
<p><a href="https://io-oi.me/tech/hexo-next-optimization/" target="_blank" rel="noopener">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></p>
<p><a href="http://www.xinxiaoyang.com/programming/2016-11-25-hexo-image-bug/" target="_blank" rel="noopener">Hexo 图片插入</a><br>更多详细情况请参考官方文档（<a href="https://hexo.io/zh-cn/docs/" 官网"" target="_blank" rel="noopener">官网</a>）</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
